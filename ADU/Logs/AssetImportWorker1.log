Unity Editor version:    2021.3.2f1 (d6360bedb9a0)
Branch:                  2021.3/staging
Build type:              Release
Batch mode:              YES
macOS version:           Version 10.15.7 (Build 19H2)
Darwin version:          19.6.0
Architecture:            x86_64
Running under Rosetta:   NO
Available memory:        8192 MB
Using pre-set license
Pro License: YES

COMMAND LINE ARGUMENTS:
/Applications/Unity/Unity.app/Contents/MacOS/Unity
-adb2
-batchMode
-noUpm
-name
AssetImportWorker1
-projectPath
/Users/mst/Documents/GitHub/ADU/ADU
-logFile
Logs/AssetImportWorker1.log
-srvPort
58800
Successfully changed project path to: /Users/mst/Documents/GitHub/ADU/ADU
/Users/mst/Documents/GitHub/ADU/ADU
[UnityMemory] Configuration Parameters - Can be set up in boot.config
    "memorysetup-bucket-allocator-granularity=16"
    "memorysetup-bucket-allocator-bucket-count=8"
    "memorysetup-bucket-allocator-block-size=33554432"
    "memorysetup-bucket-allocator-block-count=8"
    "memorysetup-main-allocator-block-size=16777216"
    "memorysetup-thread-allocator-block-size=16777216"
    "memorysetup-gfx-main-allocator-block-size=16777216"
    "memorysetup-gfx-thread-allocator-block-size=16777216"
    "memorysetup-cache-allocator-block-size=4194304"
    "memorysetup-typetree-allocator-block-size=2097152"
    "memorysetup-profiler-bucket-allocator-granularity=16"
    "memorysetup-profiler-bucket-allocator-bucket-count=8"
    "memorysetup-profiler-bucket-allocator-block-size=33554432"
    "memorysetup-profiler-bucket-allocator-block-count=8"
    "memorysetup-profiler-allocator-block-size=16777216"
    "memorysetup-profiler-editor-allocator-block-size=1048576"
    "memorysetup-temp-allocator-size-main=16777216"
    "memorysetup-job-temp-allocator-block-size=2097152"
    "memorysetup-job-temp-allocator-block-size-background=1048576"
    "memorysetup-job-temp-allocator-reduction-small-platforms=262144"
    "memorysetup-temp-allocator-size-background-worker=32768"
    "memorysetup-temp-allocator-size-job-worker=262144"
    "memorysetup-temp-allocator-size-preload-manager=33554432"
    "memorysetup-temp-allocator-size-nav-mesh-worker=65536"
    "memorysetup-temp-allocator-size-audio-worker=65536"
    "memorysetup-temp-allocator-size-cloud-worker=32768"
    "memorysetup-temp-allocator-size-gi-baking-worker=262144"
    "memorysetup-temp-allocator-size-gfx=262144"
Refreshing native plugins compatible for Editor in 143.65 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Initialize engine version: 2021.3.2f1 (d6360bedb9a0)
[Subsystems] Discovering subsystems at path /Applications/Unity/Unity.app/Contents/Resources/UnitySubsystems
[Subsystems] Discovering subsystems at path /Users/mst/Documents/GitHub/ADU/ADU/Assets
GfxDevice: creating device client; threaded=0; jobified=0
Color LCD preferred device: Intel(R) Iris(TM) Plus Graphics 645 (low power)
Metal devices available: 1
0: Intel(R) Iris(TM) Plus Graphics 645 (low power)
Using device Intel(R) Iris(TM) Plus Graphics 645 (low power)
Initializing Metal device caps: Intel(R) Iris(TM) Plus Graphics 645
Initialize mono
Mono path[0] = '/Applications/Unity/Unity.app/Contents/Managed'
Mono path[1] = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/lib/mono/unityjit-macos'
Mono config path = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56272
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: /Applications/Unity/Unity.app/Contents/PlaybackEngines/MacStandaloneSupport/UnityEditor.OSXStandalone.Extensions.dll
Registered in 0.001794 seconds.
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 131.01 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.923 seconds
Domain Reload Profiling:
	ReloadAssembly (923ms)
		BeginReloadAssembly (135ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (0ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (1ms)
		EndReloadAssembly (638ms)
			LoadAssemblies (136ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (163ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (377ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (7ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (131ms)
				BeforeProcessingInitializeOnLoad (1ms)
				ProcessInitializeOnLoadAttributes (175ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
				AfterProcessingInitializeOnLoad (0ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (0ms)
Platform modules already initialized, skipping
Registering precompiled user dll's ...
Registered in 0.016127 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 167.50 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.964 seconds
Domain Reload Profiling:
	ReloadAssembly (1965ms)
		BeginReloadAssembly (138ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (7ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (38ms)
		EndReloadAssembly (1665ms)
			LoadAssemblies (137ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (510ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (134ms)
			SetupLoadedEditorAssemblies (795ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (4ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (168ms)
				BeforeProcessingInitializeOnLoad (127ms)
				ProcessInitializeOnLoadAttributes (382ms)
				ProcessInitializeOnLoadMethodAttributes (111ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (6ms)
Platform modules already initialized, skipping
========================================================================
Worker process is ready to serve import requests
Launching external process: /Applications/Unity/Unity.app/Contents/Tools/UnityShaderCompiler
Launched and connected shader compiler UnityShaderCompiler after 0.03 seconds
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.16 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 6091 Unused Serialized files (Serialized files now loaded: 0)
Unloading 53 unused Assets / (2.6 MB). Loaded Objects now: 6531.
Memory consumption went from 385.6 MB to 383.0 MB.
Total: 5.882899 ms (FindLiveObjects: 0.631148 ms CreateObjectMapping: 0.468989 ms MarkObjects: 3.609779 ms  DeleteObjects: 1.171666 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 71967.631154 seconds.
  path: Assets/New Material.mat
  artifactKey: Guid(e175ffbb82616d14999122fd34997913) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/New Material.mat using Guid(e175ffbb82616d14999122fd34997913) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '9c404f61c71635337ef3a03e9609cf3a') in 2.665106 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002970 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.40 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.957 seconds
Domain Reload Profiling:
	ReloadAssembly (1958ms)
		BeginReloadAssembly (257ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (11ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (127ms)
		EndReloadAssembly (1531ms)
			LoadAssemblies (114ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (549ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (91ms)
			SetupLoadedEditorAssemblies (635ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (101ms)
				ProcessInitializeOnLoadAttributes (384ms)
				ProcessInitializeOnLoadMethodAttributes (134ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (28ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.07 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6625.
Memory consumption went from 381.0 MB to 378.5 MB.
Total: 11.557155 ms (FindLiveObjects: 0.712779 ms CreateObjectMapping: 0.524987 ms MarkObjects: 8.623367 ms  DeleteObjects: 1.694117 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002935 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.46 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.003 seconds
Domain Reload Profiling:
	ReloadAssembly (2005ms)
		BeginReloadAssembly (362ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (23ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (194ms)
		EndReloadAssembly (1478ms)
			LoadAssemblies (136ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (513ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (70ms)
			SetupLoadedEditorAssemblies (652ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (89ms)
				ProcessInitializeOnLoadAttributes (414ms)
				ProcessInitializeOnLoadMethodAttributes (132ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (28ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.78 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6628.
Memory consumption went from 381.3 MB to 378.8 MB.
Total: 11.488271 ms (FindLiveObjects: 0.786879 ms CreateObjectMapping: 0.667529 ms MarkObjects: 7.799868 ms  DeleteObjects: 2.232203 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002942 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.58 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.030 seconds
Domain Reload Profiling:
	ReloadAssembly (2031ms)
		BeginReloadAssembly (236ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (9ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (121ms)
		EndReloadAssembly (1618ms)
			LoadAssemblies (145ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (618ms)
			ReleaseScriptCaches (6ms)
			RebuildScriptCaches (88ms)
			SetupLoadedEditorAssemblies (611ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (13ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (105ms)
				ProcessInitializeOnLoadAttributes (365ms)
				ProcessInitializeOnLoadMethodAttributes (124ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (25ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 3.32 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6631.
Memory consumption went from 381.6 MB to 379.1 MB.
Total: 7.049043 ms (FindLiveObjects: 0.596284 ms CreateObjectMapping: 0.552262 ms MarkObjects: 4.153253 ms  DeleteObjects: 1.745914 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003071 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 2.34 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.949 seconds
Domain Reload Profiling:
	ReloadAssembly (1950ms)
		BeginReloadAssembly (232ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (110ms)
		EndReloadAssembly (1550ms)
			LoadAssemblies (115ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (578ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (87ms)
			SetupLoadedEditorAssemblies (626ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (106ms)
				ProcessInitializeOnLoadAttributes (374ms)
				ProcessInitializeOnLoadMethodAttributes (129ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (24ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.71 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6634.
Memory consumption went from 381.8 MB to 379.3 MB.
Total: 6.071975 ms (FindLiveObjects: 0.882948 ms CreateObjectMapping: 0.673851 ms MarkObjects: 3.389105 ms  DeleteObjects: 1.124864 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003112 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.66 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.430 seconds
Domain Reload Profiling:
	ReloadAssembly (2431ms)
		BeginReloadAssembly (450ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (24ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (228ms)
		EndReloadAssembly (1803ms)
			LoadAssemblies (264ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (618ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (96ms)
			SetupLoadedEditorAssemblies (719ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (114ms)
				ProcessInitializeOnLoadAttributes (431ms)
				ProcessInitializeOnLoadMethodAttributes (156ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (30ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.34 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6637.
Memory consumption went from 382.1 MB to 379.6 MB.
Total: 7.524051 ms (FindLiveObjects: 0.662046 ms CreateObjectMapping: 0.565135 ms MarkObjects: 5.016719 ms  DeleteObjects: 1.278672 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002998 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.38 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.182 seconds
Domain Reload Profiling:
	ReloadAssembly (2186ms)
		BeginReloadAssembly (352ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (21ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (198ms)
		EndReloadAssembly (1666ms)
			LoadAssemblies (134ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (617ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (93ms)
			SetupLoadedEditorAssemblies (661ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (13ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (106ms)
				ProcessInitializeOnLoadAttributes (395ms)
				ProcessInitializeOnLoadMethodAttributes (142ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (30ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 3.96 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6640.
Memory consumption went from 382.4 MB to 379.8 MB.
Total: 8.216859 ms (FindLiveObjects: 0.827016 ms CreateObjectMapping: 0.621950 ms MarkObjects: 4.993034 ms  DeleteObjects: 1.773575 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 836.425178 seconds.
  path: Assets/Sprite/().png
  artifactKey: Guid(5b3719c8eeb82cc499587950b9b23833) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/().png using Guid(5b3719c8eeb82cc499587950b9b23833) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'ab4285c631a3ecfcc599b8b9e89412bc') in 0.861411 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000082 seconds.
  path: Assets/Sprite/kawagoe.jpg
  artifactKey: Guid(1c116f8ac36060b42aeea1253326f115) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/kawagoe.jpg using Guid(1c116f8ac36060b42aeea1253326f115) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'da3e0aa33a6056afc0c78928913806e3') in 0.733639 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000074 seconds.
  path: Assets/Sprite/mati.png
  artifactKey: Guid(36adaea157070cd4c80c8d733787e75a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/mati.png using Guid(36adaea157070cd4c80c8d733787e75a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'e4da2de5b211a36a13b165d5707bf1f1') in 0.060764 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000094 seconds.
  path: Assets/Sprite/tanbatti_ro.png
  artifactKey: Guid(23232a79c9b39ef41bae5a3513b2b4fd) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/tanbatti_ro.png using Guid(23232a79c9b39ef41bae5a3513b2b4fd) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'cff00df0d585107d1be118af8c734c54') in 0.297194 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000094 seconds.
  path: Assets/Sprite/kyouin_.png
  artifactKey: Guid(f89c320546dce154ab66f279b0f05f3e) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/kyouin_.png using Guid(f89c320546dce154ab66f279b0f05f3e) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '65270229d7a5b33f0f1083f05fe410e6') in 0.301383 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000083 seconds.
  path: Assets/Sprite/teeper.png
  artifactKey: Guid(f2247267926c57c4589830d43968e0f7) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/teeper.png using Guid(f2247267926c57c4589830d43968e0f7) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '484eed49e1e87bddfba1a9a10afddede') in 0.056923 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000100 seconds.
  path: Assets/Sprite/.png
  artifactKey: Guid(cdf7a4dc8e4de8f45b5ed98ca9a99f0f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/.png using Guid(cdf7a4dc8e4de8f45b5ed98ca9a99f0f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'e59e20ec42ce83d4b9038ce6a29c5ef5') in 0.047887 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000092 seconds.
  path: Assets/Sprite/tanbatti.png
  artifactKey: Guid(a6a1bf09735343241935160eea394a07) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/tanbatti.png using Guid(a6a1bf09735343241935160eea394a07) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '6954a3463628b11239a58851ad9ff9d4') in 0.156098 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000104 seconds.
  path: Assets/Sprite/_.png
  artifactKey: Guid(138ca4f7dd62ec74e8c42c270850656f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/_.png using Guid(138ca4f7dd62ec74e8c42c270850656f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '976bbffa7290c9179aa6da507e0551ce') in 0.093493 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000080 seconds.
  path: Assets/Sprite/Background.png
  artifactKey: Guid(c5e876bc4e1934c41baff4b92f626a12) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/Background.png using Guid(c5e876bc4e1934c41baff4b92f626a12) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'd23e55119360fe9dc5c1919dad16047d') in 0.232617 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000098 seconds.
  path: Assets/Sprite/time.png
  artifactKey: Guid(35f92223fed89724d8972b63ee3e64a9) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/time.png using Guid(35f92223fed89724d8972b63ee3e64a9) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'f639bdade45e570d8d4c648b0d1ca2c8') in 0.064572 seconds 
Editor requested this worker to shutdown with reason: Scaling down because of idle timeout
AssetImportWorker is now disconnected from the server
Process exiting

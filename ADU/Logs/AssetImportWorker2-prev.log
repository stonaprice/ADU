Unity Editor version:    2021.3.2f1 (d6360bedb9a0)
Branch:                  2021.3/staging
Build type:              Release
Batch mode:              YES
macOS version:           Version 10.15.7 (Build 19H2)
Darwin version:          19.6.0
Architecture:            x86_64
Running under Rosetta:   NO
Available memory:        8192 MB
Using pre-set license
Pro License: YES

COMMAND LINE ARGUMENTS:
/Applications/Unity/Unity.app/Contents/MacOS/Unity
-adb2
-batchMode
-noUpm
-name
AssetImportWorker2
-projectPath
/Users/mst/Documents/GitHub/ADU/ADU
-logFile
Logs/AssetImportWorker2.log
-srvPort
63632
Successfully changed project path to: /Users/mst/Documents/GitHub/ADU/ADU
/Users/mst/Documents/GitHub/ADU/ADU
[UnityMemory] Configuration Parameters - Can be set up in boot.config
    "memorysetup-bucket-allocator-granularity=16"
    "memorysetup-bucket-allocator-bucket-count=8"
    "memorysetup-bucket-allocator-block-size=33554432"
    "memorysetup-bucket-allocator-block-count=8"
    "memorysetup-main-allocator-block-size=16777216"
    "memorysetup-thread-allocator-block-size=16777216"
    "memorysetup-gfx-main-allocator-block-size=16777216"
    "memorysetup-gfx-thread-allocator-block-size=16777216"
    "memorysetup-cache-allocator-block-size=4194304"
    "memorysetup-typetree-allocator-block-size=2097152"
    "memorysetup-profiler-bucket-allocator-granularity=16"
    "memorysetup-profiler-bucket-allocator-bucket-count=8"
    "memorysetup-profiler-bucket-allocator-block-size=33554432"
    "memorysetup-profiler-bucket-allocator-block-count=8"
    "memorysetup-profiler-allocator-block-size=16777216"
    "memorysetup-profiler-editor-allocator-block-size=1048576"
    "memorysetup-temp-allocator-size-main=16777216"
    "memorysetup-job-temp-allocator-block-size=2097152"
    "memorysetup-job-temp-allocator-block-size-background=1048576"
    "memorysetup-job-temp-allocator-reduction-small-platforms=262144"
    "memorysetup-temp-allocator-size-background-worker=32768"
    "memorysetup-temp-allocator-size-job-worker=262144"
    "memorysetup-temp-allocator-size-preload-manager=33554432"
    "memorysetup-temp-allocator-size-nav-mesh-worker=65536"
    "memorysetup-temp-allocator-size-audio-worker=65536"
    "memorysetup-temp-allocator-size-cloud-worker=32768"
    "memorysetup-temp-allocator-size-gi-baking-worker=262144"
    "memorysetup-temp-allocator-size-gfx=262144"
Refreshing native plugins compatible for Editor in 203.09 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Initialize engine version: 2021.3.2f1 (d6360bedb9a0)
[Subsystems] Discovering subsystems at path /Applications/Unity/Unity.app/Contents/Resources/UnitySubsystems
[Subsystems] Discovering subsystems at path /Users/mst/Documents/GitHub/ADU/ADU/Assets
GfxDevice: creating device client; threaded=0; jobified=0
Color LCD preferred device: Intel(R) Iris(TM) Plus Graphics 645 (low power)
Metal devices available: 1
0: Intel(R) Iris(TM) Plus Graphics 645 (low power)
Using device Intel(R) Iris(TM) Plus Graphics 645 (low power)
Initializing Metal device caps: Intel(R) Iris(TM) Plus Graphics 645
Initialize mono
Mono path[0] = '/Applications/Unity/Unity.app/Contents/Managed'
Mono path[1] = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/lib/mono/unityjit-macos'
Mono config path = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56420
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: /Applications/Unity/Unity.app/Contents/PlaybackEngines/MacStandaloneSupport/UnityEditor.OSXStandalone.Extensions.dll
Registered in 0.002294 seconds.
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 198.51 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.524 seconds
Domain Reload Profiling:
	ReloadAssembly (1525ms)
		BeginReloadAssembly (222ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (0ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (1ms)
		EndReloadAssembly (1077ms)
			LoadAssemblies (222ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (291ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (67ms)
			SetupLoadedEditorAssemblies (620ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (199ms)
				BeforeProcessingInitializeOnLoad (2ms)
				ProcessInitializeOnLoadAttributes (295ms)
				ProcessInitializeOnLoadMethodAttributes (112ms)
				AfterProcessingInitializeOnLoad (0ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (0ms)
Platform modules already initialized, skipping
Registering precompiled user dll's ...
Registered in 0.005267 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 166.97 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.301 seconds
Domain Reload Profiling:
	ReloadAssembly (2303ms)
		BeginReloadAssembly (197ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (59ms)
		EndReloadAssembly (1885ms)
			LoadAssemblies (292ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (518ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (106ms)
			SetupLoadedEditorAssemblies (896ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (5ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (167ms)
				BeforeProcessingInitializeOnLoad (146ms)
				ProcessInitializeOnLoadAttributes (437ms)
				ProcessInitializeOnLoadMethodAttributes (138ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (6ms)
Platform modules already initialized, skipping
========================================================================
Worker process is ready to serve import requests
Launching external process: /Applications/Unity/Unity.app/Contents/Tools/UnityShaderCompiler
Launched and connected shader compiler UnityShaderCompiler after 0.02 seconds
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.68 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5316 Unused Serialized files (Serialized files now loaded: 0)
Unloading 47 unused Assets / (2.1 MB). Loaded Objects now: 5792.
Memory consumption went from 379.7 MB to 377.6 MB.
Total: 26.154800 ms (FindLiveObjects: 1.422487 ms CreateObjectMapping: 0.764359 ms MarkObjects: 18.727730 ms  DeleteObjects: 5.237848 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.006457 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.94 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  5.139 seconds
Domain Reload Profiling:
	ReloadAssembly (5142ms)
		BeginReloadAssembly (574ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (26ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (290ms)
		EndReloadAssembly (4139ms)
			LoadAssemblies (267ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1290ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (197ms)
			SetupLoadedEditorAssemblies (2077ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (35ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (262ms)
				ProcessInitializeOnLoadAttributes (1122ms)
				ProcessInitializeOnLoadMethodAttributes (640ms)
				AfterProcessingInitializeOnLoad (13ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (101ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 6.21 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5076 Unused Serialized files (Serialized files now loaded: 0)
Unloading 41 unused Assets / (2.1 MB). Loaded Objects now: 5795.
Memory consumption went from 361.4 MB to 359.3 MB.
Total: 19.530812 ms (FindLiveObjects: 1.971147 ms CreateObjectMapping: 0.999507 ms MarkObjects: 12.651305 ms  DeleteObjects: 3.905602 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 195800.962952 seconds.
  path: Assets/kawagoe.jpg
  artifactKey: Guid(1c116f8ac36060b42aeea1253326f115) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/kawagoe.jpg using Guid(1c116f8ac36060b42aeea1253326f115) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'da3e0aa33a6056afc0c78928913806e3') in 2.321832 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.003704 seconds.
  path: Assets/New Material.mat
  artifactKey: Guid(e175ffbb82616d14999122fd34997913) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/New Material.mat using Guid(e175ffbb82616d14999122fd34997913) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '9c404f61c71635337ef3a03e9609cf3a') in 2.538771 seconds 
========================================================================
Received Import Request.
  Time since last request: 456.225227 seconds.
  path: Assets/Script(Control)
  artifactKey: Guid(87bf61c77395ed74a8ad1a1c582f3c70) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control) using Guid(87bf61c77395ed74a8ad1a1c582f3c70) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '8cc997811c2b843ded88cd334001f56c') in 0.032687 seconds 
========================================================================
Received Import Request.
  Time since last request: 63.018577 seconds.
  path: Assets/Script(Control)/NewBehaviourScript.cs
  artifactKey: Guid(978c145e1a6eb486b846bd67726a6a55) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/NewBehaviourScript.cs using Guid(978c145e1a6eb486b846bd67726a6a55) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'd8e7e8a95f25dbe4916c72730810881a') in 0.595314 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005362 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.55 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  3.788 seconds
Domain Reload Profiling:
	ReloadAssembly (3791ms)
		BeginReloadAssembly (1433ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (87ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (446ms)
		EndReloadAssembly (2195ms)
			LoadAssemblies (1240ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (823ms)
			ReleaseScriptCaches (21ms)
			RebuildScriptCaches (75ms)
			SetupLoadedEditorAssemblies (603ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (83ms)
				ProcessInitializeOnLoadAttributes (381ms)
				ProcessInitializeOnLoadMethodAttributes (123ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (35ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 3.07 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5085 Unused Serialized files (Serialized files now loaded: 0)
Unloading 41 unused Assets / (2.1 MB). Loaded Objects now: 5893.
Memory consumption went from 382.5 MB to 380.4 MB.
Total: 11.611667 ms (FindLiveObjects: 1.511040 ms CreateObjectMapping: 0.675095 ms MarkObjects: 7.344208 ms  DeleteObjects: 2.078658 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 215.070531 seconds.
  path: Assets/Script(Control)/DestroyRigidbody.cs
  artifactKey: Guid(978c145e1a6eb486b846bd67726a6a55) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/DestroyRigidbody.cs using Guid(978c145e1a6eb486b846bd67726a6a55) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'b9f2b0c367fd4e7a2c897ffd322c0712') in 0.093733 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003172 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 4.95 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.445 seconds
Domain Reload Profiling:
	ReloadAssembly (2446ms)
		BeginReloadAssembly (473ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (25ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (187ms)
		EndReloadAssembly (1815ms)
			LoadAssemblies (285ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (583ms)
			ReleaseScriptCaches (22ms)
			RebuildScriptCaches (180ms)
			SetupLoadedEditorAssemblies (586ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (5ms)
				BeforeProcessingInitializeOnLoad (135ms)
				ProcessInitializeOnLoadAttributes (323ms)
				ProcessInitializeOnLoadMethodAttributes (109ms)
				AfterProcessingInitializeOnLoad (1ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (20ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 3.97 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5085 Unused Serialized files (Serialized files now loaded: 0)
Unloading 41 unused Assets / (2.1 MB). Loaded Objects now: 5896.
Memory consumption went from 382.6 MB to 380.5 MB.
Total: 29.220192 ms (FindLiveObjects: 1.108846 ms CreateObjectMapping: 0.580906 ms MarkObjects: 26.656954 ms  DeleteObjects: 0.872237 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 133.799424 seconds.
  path: Assets/Prefab
  artifactKey: Guid(f25274fd3242e3140aae662b928e66fe) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Prefab using Guid(f25274fd3242e3140aae662b928e66fe) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '87d0094e19f7b5b82a0e4543f6d14de4') in 0.190330 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000162 seconds.
  path: Assets/Prefab/Unit1.prefab
  artifactKey: Guid(98579e72a18120d4285ff1c733d98d3c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Prefab/Unit1.prefab using Guid(98579e72a18120d4285ff1c733d98d3c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '65edcdc4f687b53c58158c39e02b5cc5') in 1.380912 seconds 
========================================================================
Received Import Request.
  Time since last request: 421.480148 seconds.
  path: Assets/Script(Control)/Unit
  artifactKey: Guid(1f087c8fc747d1548a81e657dbc0798a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/Unit using Guid(1f087c8fc747d1548a81e657dbc0798a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '0c2a5745ac802d23bff22e6536c72c85') in 0.019441 seconds 
========================================================================
Received Import Request.
  Time since last request: 1.147370 seconds.
  path: Assets/Script(Control)/Unit/SummonUnit.cs
  artifactKey: Guid(b3e8832b9df08fc49a806c046c81eba4) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/Unit/SummonUnit.cs using Guid(b3e8832b9df08fc49a806c046c81eba4) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '865a6cf39ea16446277d74ad1f3db781') in 0.065855 seconds 
========================================================================
Received Import Request.
  Time since last request: 737.339046 seconds.
  path: Assets/Script(Control)/StartText.cs
  artifactKey: Guid(df66043573c302d46a91c203dc2b30bb) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/StartText.cs using Guid(df66043573c302d46a91c203dc2b30bb) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'a15fe36b32768bfda5c74df5a9c735cc') in 0.067232 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.009306 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 3.77 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.847 seconds
Domain Reload Profiling:
	ReloadAssembly (2854ms)
		BeginReloadAssembly (839ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (80ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (463ms)
		EndReloadAssembly (1671ms)
			LoadAssemblies (301ms)
			RebuildTransferFunctionScriptingTraits (4ms)
			SetupTypeCache (590ms)
			ReleaseScriptCaches (15ms)
			RebuildScriptCaches (81ms)
			SetupLoadedEditorAssemblies (649ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (4ms)
				BeforeProcessingInitializeOnLoad (94ms)
				ProcessInitializeOnLoadAttributes (394ms)
				ProcessInitializeOnLoadMethodAttributes (141ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (31ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 3.78 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5085 Unused Serialized files (Serialized files now loaded: 0)
Unloading 45 unused Assets / (2.1 MB). Loaded Objects now: 5940.
Memory consumption went from 387.2 MB to 385.2 MB.
Total: 30.431013 ms (FindLiveObjects: 1.152442 ms CreateObjectMapping: 0.634671 ms MarkObjects: 26.917528 ms  DeleteObjects: 1.724643 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 148.268875 seconds.
  path: Assets/Scripts
  artifactKey: Guid(f7fc301037c0b114c88f338ec2a2b77f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scripts using Guid(f7fc301037c0b114c88f338ec2a2b77f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '1da65b400f51114a5fc91da350c71648') in 0.068899 seconds 
========================================================================
Received Import Request.
  Time since last request: 3.860044 seconds.
  path: Assets/Script(Control)/DestroyRigidbody.cs
  artifactKey: Guid(978c145e1a6eb486b846bd67726a6a55) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/DestroyRigidbody.cs using Guid(978c145e1a6eb486b846bd67726a6a55) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'a5880ce08c50b47f97c92a83fe568604') in 0.034941 seconds 
========================================================================
Received Import Request.
  Time since last request: 19.651283 seconds.
  path: Assets/Prefab/DestroyRigidbody.cs
  artifactKey: Guid(3e32274944af44436a3611447bed9839) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Prefab/DestroyRigidbody.cs using Guid(3e32274944af44436a3611447bed9839) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '0c3977bd32f3195535fedf437bc4c391') in 0.001393 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003056 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.04 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.872 seconds
Domain Reload Profiling:
	ReloadAssembly (1873ms)
		BeginReloadAssembly (344ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (25ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (195ms)
		EndReloadAssembly (1377ms)
			LoadAssemblies (112ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (523ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (74ms)
			SetupLoadedEditorAssemblies (550ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (89ms)
				ProcessInitializeOnLoadAttributes (336ms)
				ProcessInitializeOnLoadMethodAttributes (111ms)
				AfterProcessingInitializeOnLoad (1ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (21ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.99 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5085 Unused Serialized files (Serialized files now loaded: 0)
Unloading 41 unused Assets / (2.1 MB). Loaded Objects now: 5943.
Memory consumption went from 387.4 MB to 385.3 MB.
Total: 6.561449 ms (FindLiveObjects: 0.538431 ms CreateObjectMapping: 0.705502 ms MarkObjects: 4.596246 ms  DeleteObjects: 0.719170 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 140.974851 seconds.
  path: Assets/Prefab/Unit1.prefab
  artifactKey: Guid(98579e72a18120d4285ff1c733d98d3c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Prefab/Unit1.prefab using Guid(98579e72a18120d4285ff1c733d98d3c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '51ff397af497d8495178947f4ad7a028') in 0.628262 seconds 
========================================================================
Received Import Request.
  Time since last request: 3.707198 seconds.
  path: Assets/Prefab/Unit1.prefab
  artifactKey: Guid(98579e72a18120d4285ff1c733d98d3c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Prefab/Unit1.prefab using Guid(98579e72a18120d4285ff1c733d98d3c) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '6f58cd3b24c819c4eb2062dcb8b04505') in 0.039681 seconds 
========================================================================
Received Import Request.
  Time since last request: 5.928610 seconds.
  path: Assets/Prefab/Enemy1.prefab
  artifactKey: Guid(74bdef97ab2f7654ca154aa19afc8bd6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Prefab/Enemy1.prefab using Guid(74bdef97ab2f7654ca154aa19afc8bd6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '87a5e616075a2cf582fd1fa12756a7a0') in 0.036179 seconds 
========================================================================
Received Import Request.
  Time since last request: 3.765981 seconds.
  path: Assets/Prefab/Enemy1.prefab
  artifactKey: Guid(74bdef97ab2f7654ca154aa19afc8bd6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Prefab/Enemy1.prefab using Guid(74bdef97ab2f7654ca154aa19afc8bd6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '4f7857b6f74bf80a3f3b7d322064fc5e') in 0.031952 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002946 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.00 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.779 seconds
Domain Reload Profiling:
	ReloadAssembly (1780ms)
		BeginReloadAssembly (228ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (11ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (111ms)
		EndReloadAssembly (1411ms)
			LoadAssemblies (110ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (494ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (71ms)
			SetupLoadedEditorAssemblies (610ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (97ms)
				ProcessInitializeOnLoadAttributes (364ms)
				ProcessInitializeOnLoadMethodAttributes (133ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (28ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.94 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5085 Unused Serialized files (Serialized files now loaded: 0)
Unloading 45 unused Assets / (2.1 MB). Loaded Objects now: 5987.
Memory consumption went from 387.9 MB to 385.8 MB.
Total: 5.953397 ms (FindLiveObjects: 0.510040 ms CreateObjectMapping: 0.474412 ms MarkObjects: 3.733659 ms  DeleteObjects: 1.234132 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 

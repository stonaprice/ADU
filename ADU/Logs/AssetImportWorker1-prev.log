Unity Editor version:    2021.3.2f1 (d6360bedb9a0)
Branch:                  2021.3/staging
Build type:              Release
Batch mode:              YES
macOS version:           Version 10.15.7 (Build 19H2)
Darwin version:          19.6.0
Architecture:            x86_64
Running under Rosetta:   NO
Available memory:        8192 MB
Using pre-set license
Pro License: YES

COMMAND LINE ARGUMENTS:
/Applications/Unity/Unity.app/Contents/MacOS/Unity
-adb2
-batchMode
-noUpm
-name
AssetImportWorker1
-projectPath
/Users/mst/Documents/GitHub/ADU/ADU
-logFile
Logs/AssetImportWorker1.log
-srvPort
<<<<<<< HEAD
58800
Successfully changed project path to: /Users/mst/Documents/GitHub/ADU/ADU
/Users/mst/Documents/GitHub/ADU/ADU
=======
51978
Successfully changed project path to: C:/Users/kuma/Documents/GitHub/ADU/ADU
C:/Users/kuma/Documents/GitHub/ADU/ADU
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
[UnityMemory] Configuration Parameters - Can be set up in boot.config
    "memorysetup-bucket-allocator-granularity=16"
    "memorysetup-bucket-allocator-bucket-count=8"
    "memorysetup-bucket-allocator-block-size=33554432"
    "memorysetup-bucket-allocator-block-count=8"
    "memorysetup-main-allocator-block-size=16777216"
    "memorysetup-thread-allocator-block-size=16777216"
    "memorysetup-gfx-main-allocator-block-size=16777216"
    "memorysetup-gfx-thread-allocator-block-size=16777216"
    "memorysetup-cache-allocator-block-size=4194304"
    "memorysetup-typetree-allocator-block-size=2097152"
    "memorysetup-profiler-bucket-allocator-granularity=16"
    "memorysetup-profiler-bucket-allocator-bucket-count=8"
    "memorysetup-profiler-bucket-allocator-block-size=33554432"
    "memorysetup-profiler-bucket-allocator-block-count=8"
    "memorysetup-profiler-allocator-block-size=16777216"
    "memorysetup-profiler-editor-allocator-block-size=1048576"
    "memorysetup-temp-allocator-size-main=16777216"
    "memorysetup-job-temp-allocator-block-size=2097152"
    "memorysetup-job-temp-allocator-block-size-background=1048576"
    "memorysetup-job-temp-allocator-reduction-small-platforms=262144"
    "memorysetup-temp-allocator-size-background-worker=32768"
    "memorysetup-temp-allocator-size-job-worker=262144"
    "memorysetup-temp-allocator-size-preload-manager=33554432"
    "memorysetup-temp-allocator-size-nav-mesh-worker=65536"
    "memorysetup-temp-allocator-size-audio-worker=65536"
    "memorysetup-temp-allocator-size-cloud-worker=32768"
    "memorysetup-temp-allocator-size-gi-baking-worker=262144"
    "memorysetup-temp-allocator-size-gfx=262144"
<<<<<<< HEAD
Refreshing native plugins compatible for Editor in 143.65 ms, found 2 plugins.
=======
Refreshing native plugins compatible for Editor in 81.36 ms, found 3 plugins.
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
Preloading 0 native plugins for Editor in 0.00 ms.
Initialize engine version: 2021.3.2f1 (d6360bedb9a0)
[Subsystems] Discovering subsystems at path /Applications/Unity/Unity.app/Contents/Resources/UnitySubsystems
[Subsystems] Discovering subsystems at path /Users/mst/Documents/GitHub/ADU/ADU/Assets
GfxDevice: creating device client; threaded=0; jobified=0
Color LCD preferred device: Intel(R) Iris(TM) Plus Graphics 645 (low power)
Metal devices available: 1
0: Intel(R) Iris(TM) Plus Graphics 645 (low power)
Using device Intel(R) Iris(TM) Plus Graphics 645 (low power)
Initializing Metal device caps: Intel(R) Iris(TM) Plus Graphics 645
Initialize mono
<<<<<<< HEAD
Mono path[0] = '/Applications/Unity/Unity.app/Contents/Managed'
Mono path[1] = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/lib/mono/unityjit-macos'
Mono config path = '/Applications/Unity/Unity.app/Contents/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56272
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: /Applications/Unity/Unity.app/Contents/PlaybackEngines/MacStandaloneSupport/UnityEditor.OSXStandalone.Extensions.dll
Registered in 0.001794 seconds.
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 131.01 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.923 seconds
Domain Reload Profiling:
	ReloadAssembly (923ms)
		BeginReloadAssembly (135ms)
=======
Mono path[0] = 'C:/Program Files/Unity/Hub/Editor/2021.3.2f1/Editor/Data/Managed'
Mono path[1] = 'C:/Program Files/Unity/Hub/Editor/2021.3.2f1/Editor/Data/MonoBleedingEdge/lib/mono/unityjit-win32'
Mono config path = 'C:/Program Files/Unity/Hub/Editor/2021.3.2f1/Editor/Data/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56132
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: C:/Program Files/Unity/Hub/Editor/2021.3.2f1/Editor/Data/PlaybackEngines/WindowsStandaloneSupport/UnityEditor.WindowsStandalone.Extensions.dll
Registered in 0.005873 seconds.
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 77.34 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.447 seconds
Domain Reload Profiling:
	ReloadAssembly (447ms)
		BeginReloadAssembly (50ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (0ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (1ms)
<<<<<<< HEAD
		EndReloadAssembly (638ms)
			LoadAssemblies (136ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (163ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (377ms)
=======
		EndReloadAssembly (315ms)
			LoadAssemblies (48ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (70ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (20ms)
			SetupLoadedEditorAssemblies (192ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (7ms)
				SetLoadedEditorAssemblies (0ms)
<<<<<<< HEAD
				RefreshPlugins (131ms)
				BeforeProcessingInitializeOnLoad (1ms)
				ProcessInitializeOnLoadAttributes (175ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
=======
				RefreshPlugins (77ms)
				BeforeProcessingInitializeOnLoad (1ms)
				ProcessInitializeOnLoadAttributes (78ms)
				ProcessInitializeOnLoadMethodAttributes (31ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
				AfterProcessingInitializeOnLoad (0ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (0ms)
Platform modules already initialized, skipping
Registering precompiled user dll's ...
<<<<<<< HEAD
Registered in 0.016127 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 167.50 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.964 seconds
Domain Reload Profiling:
	ReloadAssembly (1965ms)
		BeginReloadAssembly (138ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (7ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (38ms)
		EndReloadAssembly (1665ms)
			LoadAssemblies (137ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (510ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (134ms)
			SetupLoadedEditorAssemblies (795ms)
=======
Registered in 0.006769 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 84.86 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.903 seconds
Domain Reload Profiling:
	ReloadAssembly (903ms)
		BeginReloadAssembly (72ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (3ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (15ms)
		EndReloadAssembly (743ms)
			LoadAssemblies (57ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (189ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (50ms)
			SetupLoadedEditorAssemblies (409ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (4ms)
				SetLoadedEditorAssemblies (0ms)
<<<<<<< HEAD
				RefreshPlugins (168ms)
				BeforeProcessingInitializeOnLoad (127ms)
				ProcessInitializeOnLoadAttributes (382ms)
				ProcessInitializeOnLoadMethodAttributes (111ms)
				AfterProcessingInitializeOnLoad (2ms)
=======
				RefreshPlugins (85ms)
				BeforeProcessingInitializeOnLoad (81ms)
				ProcessInitializeOnLoadAttributes (177ms)
				ProcessInitializeOnLoadMethodAttributes (56ms)
				AfterProcessingInitializeOnLoad (6ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (6ms)
Platform modules already initialized, skipping
========================================================================
Worker process is ready to serve import requests
<<<<<<< HEAD
Launching external process: /Applications/Unity/Unity.app/Contents/Tools/UnityShaderCompiler
Launched and connected shader compiler UnityShaderCompiler after 0.03 seconds
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.16 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 6091 Unused Serialized files (Serialized files now loaded: 0)
Unloading 53 unused Assets / (2.6 MB). Loaded Objects now: 6531.
Memory consumption went from 385.6 MB to 383.0 MB.
Total: 5.882899 ms (FindLiveObjects: 0.631148 ms CreateObjectMapping: 0.468989 ms MarkObjects: 3.609779 ms  DeleteObjects: 1.171666 ms)
=======
Launched and connected shader compiler UnityShaderCompiler.exe after 0.04 seconds
Refreshing native plugins compatible for Editor in 1.12 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 6091 Unused Serialized files (Serialized files now loaded: 0)
Unloading 51 unused Assets / (2.3 MB). Loaded Objects now: 6533.
Memory consumption went from 254.3 MB to 252.0 MB.
Total: 2.968400 ms (FindLiveObjects: 0.371200 ms CreateObjectMapping: 0.218000 ms MarkObjects: 1.959900 ms  DeleteObjects: 0.418200 ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
<<<<<<< HEAD
  Time since last request: 71967.631154 seconds.
  path: Assets/New Material.mat
  artifactKey: Guid(e175ffbb82616d14999122fd34997913) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/New Material.mat using Guid(e175ffbb82616d14999122fd34997913) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '9c404f61c71635337ef3a03e9609cf3a') in 2.665106 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002970 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.40 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.957 seconds
Domain Reload Profiling:
	ReloadAssembly (1958ms)
		BeginReloadAssembly (257ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (11ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (127ms)
		EndReloadAssembly (1531ms)
			LoadAssemblies (114ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (549ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (91ms)
			SetupLoadedEditorAssemblies (635ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (101ms)
				ProcessInitializeOnLoadAttributes (384ms)
				ProcessInitializeOnLoadMethodAttributes (134ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (28ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.07 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6625.
Memory consumption went from 381.0 MB to 378.5 MB.
Total: 11.557155 ms (FindLiveObjects: 0.712779 ms CreateObjectMapping: 0.524987 ms MarkObjects: 8.623367 ms  DeleteObjects: 1.694117 ms)
=======
  Time since last request: 870427.115043 seconds.
  path: Assets/Readme.asset
  artifactKey: Guid(8105016687592461f977c054a80ce2f2) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Readme.asset using Guid(8105016687592461f977c054a80ce2f2) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '3f8df6bccfaeea7c160e2ca3bda91111') in 0.030692 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000020 seconds.
  path: Assets/UniversalRenderPipelineGlobalSettings 1.asset
  artifactKey: Guid(fc2254c3990d62149a0ab26786ba22d1) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/UniversalRenderPipelineGlobalSettings 1.asset using Guid(fc2254c3990d62149a0ab26786ba22d1) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '18041a0aed35a8592da93d89c612d66c') in 0.007500 seconds 
========================================================================
Received Import Request.
  Time since last request: 6.944716 seconds.
  path: Assets/Scenes/Fight/Lightmap-0_comp_dir.png
  artifactKey: Guid(4d337cb9fd1cd994fa6dba401ce201dc) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/Fight/Lightmap-0_comp_dir.png using Guid(4d337cb9fd1cd994fa6dba401ce201dc) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '719f2a18f8d106de0473c446215a0fc5') in 0.058193 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000023 seconds.
  path: Assets/Scenes/Fight/Lightmap-0_comp_light.exr
  artifactKey: Guid(2a8ac5fae1cd30c4da0eda6633894520) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/Fight/Lightmap-0_comp_light.exr using Guid(2a8ac5fae1cd30c4da0eda6633894520) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '73e83a8739ae075a2d2a4e85d9a928fd') in 0.031545 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005396 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.86 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.819 seconds
Domain Reload Profiling:
	ReloadAssembly (819ms)
		BeginReloadAssembly (98ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (33ms)
		EndReloadAssembly (650ms)
			LoadAssemblies (64ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (206ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (305ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (61ms)
				ProcessInitializeOnLoadAttributes (163ms)
				ProcessInitializeOnLoadMethodAttributes (63ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (10ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.84 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5855 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6541.
Memory consumption went from 239.4 MB to 237.1 MB.
Total: 3.397100 ms (FindLiveObjects: 0.453800 ms CreateObjectMapping: 0.239000 ms MarkObjects: 2.075900 ms  DeleteObjects: 0.626000 ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
<<<<<<< HEAD
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
=======
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
<<<<<<< HEAD
Registered in 0.002935 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.46 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.003 seconds
Domain Reload Profiling:
	ReloadAssembly (2005ms)
		BeginReloadAssembly (362ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (23ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (194ms)
		EndReloadAssembly (1478ms)
			LoadAssemblies (136ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (513ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (70ms)
			SetupLoadedEditorAssemblies (652ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (89ms)
				ProcessInitializeOnLoadAttributes (414ms)
				ProcessInitializeOnLoadMethodAttributes (132ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (28ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.78 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6628.
Memory consumption went from 381.3 MB to 378.8 MB.
Total: 11.488271 ms (FindLiveObjects: 0.786879 ms CreateObjectMapping: 0.667529 ms MarkObjects: 7.799868 ms  DeleteObjects: 2.232203 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002942 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.58 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.030 seconds
Domain Reload Profiling:
	ReloadAssembly (2031ms)
		BeginReloadAssembly (236ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (9ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (121ms)
		EndReloadAssembly (1618ms)
			LoadAssemblies (145ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (618ms)
			ReleaseScriptCaches (6ms)
			RebuildScriptCaches (88ms)
			SetupLoadedEditorAssemblies (611ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (13ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (105ms)
				ProcessInitializeOnLoadAttributes (365ms)
				ProcessInitializeOnLoadMethodAttributes (124ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (25ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 3.32 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6631.
Memory consumption went from 381.6 MB to 379.1 MB.
Total: 7.049043 ms (FindLiveObjects: 0.596284 ms CreateObjectMapping: 0.552262 ms MarkObjects: 4.153253 ms  DeleteObjects: 1.745914 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003071 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 2.34 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.949 seconds
Domain Reload Profiling:
	ReloadAssembly (1950ms)
		BeginReloadAssembly (232ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (110ms)
		EndReloadAssembly (1550ms)
			LoadAssemblies (115ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (578ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (87ms)
			SetupLoadedEditorAssemblies (626ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (106ms)
				ProcessInitializeOnLoadAttributes (374ms)
				ProcessInitializeOnLoadMethodAttributes (129ms)
				AfterProcessingInitializeOnLoad (2ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (24ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.71 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6634.
Memory consumption went from 381.8 MB to 379.3 MB.
Total: 6.071975 ms (FindLiveObjects: 0.882948 ms CreateObjectMapping: 0.673851 ms MarkObjects: 3.389105 ms  DeleteObjects: 1.124864 ms)
=======
Registered in 0.005671 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.40 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.304 seconds
Domain Reload Profiling:
	ReloadAssembly (1305ms)
		BeginReloadAssembly (92ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (3ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (27ms)
		EndReloadAssembly (1148ms)
			LoadAssemblies (58ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (427ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (68ms)
			SetupLoadedEditorAssemblies (508ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (16ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (93ms)
				ProcessInitializeOnLoadAttributes (274ms)
				ProcessInitializeOnLoadMethodAttributes (111ms)
				AfterProcessingInitializeOnLoad (10ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 4.57 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5855 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6544.
Memory consumption went from 239.4 MB to 237.1 MB.
Total: 6.931700 ms (FindLiveObjects: 0.983000 ms CreateObjectMapping: 0.933800 ms MarkObjects: 3.783200 ms  DeleteObjects: 1.226800 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 1013.810631 seconds.
  path: Assets/Sprite/80s_Retro_text.png
  artifactKey: Guid(c4831aca3f0a21642925af1b4fe634b5) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/80s_Retro_text.png using Guid(c4831aca3f0a21642925af1b4fe634b5) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'f05e1a43c22953086a6de9e1341a86a9') in 0.148217 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000023 seconds.
  path: Assets/Sprite/EnemyTarget.prefab
  artifactKey: Guid(192c70229cc45934488572d2045b3599) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/EnemyTarget.prefab using Guid(192c70229cc45934488572d2045b3599) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '465b70816d59f77143ccbbc8b9b2e322') in 0.154799 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000041 seconds.
  path: Assets/Sprite/stb.png
  artifactKey: Guid(0879251ae7113ad4b8e88b17f2cf47e7) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/stb.png using Guid(0879251ae7113ad4b8e88b17f2cf47e7) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'a4b6f09d2521b86fdc1fd07b8b9fb68e') in 0.046527 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000019 seconds.
  path: Assets/Sprite/report.png
  artifactKey: Guid(5f91667eb77e6ad499d43ad6b3c2085f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/report.png using Guid(5f91667eb77e6ad499d43ad6b3c2085f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '3b0aa909a414b88e951801b3bd41c985') in 0.020941 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000018 seconds.
  path: Assets/Sprite/CostFill1.png
  artifactKey: Guid(c47e097de06822d49af10d5790ff567d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/CostFill1.png using Guid(c47e097de06822d49af10d5790ff567d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '365e6513579585723350d2427142bdb7') in 0.096773 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000057 seconds.
  path: Assets/Sprite/triangle.png
  artifactKey: Guid(6b997679dab0d084d9303cb013e06047) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/triangle.png using Guid(6b997679dab0d084d9303cb013e06047) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '379df664b87eabb27ffde1eda6dc81fb') in 0.026038 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000027 seconds.
  path: Assets/Sprite/S__148537346.jpg
  artifactKey: Guid(8f21bd5144298704e8f6b8f1e75aaa9d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/S__148537346.jpg using Guid(8f21bd5144298704e8f6b8f1e75aaa9d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '7d1512a445e17756061ce89253412a21') in 0.192116 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000034 seconds.
  path: Assets/Sprite/_.png
  artifactKey: Guid(138ca4f7dd62ec74e8c42c270850656f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/_.png using Guid(138ca4f7dd62ec74e8c42c270850656f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'cb1b566071e2095b42a8b7234adc3c12') in 0.019112 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000022 seconds.
  path: Assets/Sprite/Background.png
  artifactKey: Guid(c5e876bc4e1934c41baff4b92f626a12) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/Background.png using Guid(c5e876bc4e1934c41baff4b92f626a12) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '8d492adad9c01c390caae3e5b5661065') in 0.097199 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000023 seconds.
  path: Assets/Sprite/time.png
  artifactKey: Guid(35f92223fed89724d8972b63ee3e64a9) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/time.png using Guid(35f92223fed89724d8972b63ee3e64a9) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '95acd7f08c88792e20cd7ba21a72a137') in 0.029202 seconds 
========================================================================
Received Import Request.
  Time since last request: 149.390236 seconds.
  path: Assets/Scenes/GameOver.unity
  artifactKey: Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/GameOver.unity using Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '52327a9eb4819c5ab59fa04a409c814a') in 0.004076 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.007175 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.74 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.844 seconds
Domain Reload Profiling:
	ReloadAssembly (844ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (34ms)
		EndReloadAssembly (676ms)
			LoadAssemblies (57ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (210ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (34ms)
			SetupLoadedEditorAssemblies (314ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (65ms)
				ProcessInitializeOnLoadAttributes (165ms)
				ProcessInitializeOnLoadMethodAttributes (66ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.87 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5862 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6627.
Memory consumption went from 242.6 MB to 240.2 MB.
Total: 2.938400 ms (FindLiveObjects: 0.370100 ms CreateObjectMapping: 0.206800 ms MarkObjects: 1.873400 ms  DeleteObjects: 0.487200 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005044 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.76 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.845 seconds
Domain Reload Profiling:
	ReloadAssembly (845ms)
		BeginReloadAssembly (101ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (31ms)
		EndReloadAssembly (677ms)
			LoadAssemblies (66ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (199ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (315ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (73ms)
				ProcessInitializeOnLoadAttributes (167ms)
				ProcessInitializeOnLoadMethodAttributes (59ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.96 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6630.
Memory consumption went from 242.7 MB to 240.3 MB.
Total: 3.179600 ms (FindLiveObjects: 0.318800 ms CreateObjectMapping: 0.198100 ms MarkObjects: 2.144700 ms  DeleteObjects: 0.517300 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004898 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.77 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.809 seconds
Domain Reload Profiling:
	ReloadAssembly (809ms)
		BeginReloadAssembly (93ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (26ms)
		EndReloadAssembly (649ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (176ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (314ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (63ms)
				ProcessInitializeOnLoadAttributes (169ms)
				ProcessInitializeOnLoadMethodAttributes (65ms)
				AfterProcessingInitializeOnLoad (8ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.87 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6633.
Memory consumption went from 242.7 MB to 240.3 MB.
Total: 3.585700 ms (FindLiveObjects: 0.381100 ms CreateObjectMapping: 0.220200 ms MarkObjects: 2.202300 ms  DeleteObjects: 0.781200 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 237.047150 seconds.
  path: Assets/Scenes/GameOver.unity
  artifactKey: Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/GameOver.unity using Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'bbdd00c90b2e6302d51921df799159f6') in 0.009148 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005136 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.68 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.819 seconds
Domain Reload Profiling:
	ReloadAssembly (820ms)
		BeginReloadAssembly (92ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (26ms)
		EndReloadAssembly (653ms)
			LoadAssemblies (60ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (203ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (40ms)
			SetupLoadedEditorAssemblies (292ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (60ms)
				ProcessInitializeOnLoadAttributes (155ms)
				ProcessInitializeOnLoadMethodAttributes (60ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.87 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6636.
Memory consumption went from 242.7 MB to 240.3 MB.
Total: 3.307400 ms (FindLiveObjects: 0.442900 ms CreateObjectMapping: 0.222900 ms MarkObjects: 2.084300 ms  DeleteObjects: 0.555100 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004993 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.72 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.856 seconds
Domain Reload Profiling:
	ReloadAssembly (856ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (690ms)
			LoadAssemblies (64ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (195ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (34ms)
			SetupLoadedEditorAssemblies (325ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (61ms)
				ProcessInitializeOnLoadAttributes (185ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.39 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6639.
Memory consumption went from 242.7 MB to 240.3 MB.
Total: 3.295800 ms (FindLiveObjects: 0.379200 ms CreateObjectMapping: 0.184400 ms MarkObjects: 2.111200 ms  DeleteObjects: 0.619700 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004903 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.90 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.863 seconds
Domain Reload Profiling:
	ReloadAssembly (864ms)
		BeginReloadAssembly (100ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (3ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (685ms)
			LoadAssemblies (67ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (206ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (39ms)
			SetupLoadedEditorAssemblies (308ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (63ms)
				ProcessInitializeOnLoadAttributes (165ms)
				ProcessInitializeOnLoadMethodAttributes (65ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.85 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6642.
Memory consumption went from 242.7 MB to 240.3 MB.
Total: 3.465600 ms (FindLiveObjects: 0.347100 ms CreateObjectMapping: 0.197900 ms MarkObjects: 2.318600 ms  DeleteObjects: 0.600700 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005365 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.74 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.885 seconds
Domain Reload Profiling:
	ReloadAssembly (885ms)
		BeginReloadAssembly (93ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (3ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (29ms)
		EndReloadAssembly (726ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (238ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (52ms)
			SetupLoadedEditorAssemblies (300ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (61ms)
				ProcessInitializeOnLoadAttributes (161ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.67 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6645.
Memory consumption went from 242.7 MB to 240.4 MB.
Total: 3.006600 ms (FindLiveObjects: 0.355400 ms CreateObjectMapping: 0.178700 ms MarkObjects: 1.982900 ms  DeleteObjects: 0.488300 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005328 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.52 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.861 seconds
Domain Reload Profiling:
	ReloadAssembly (861ms)
		BeginReloadAssembly (97ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (693ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (210ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (34ms)
			SetupLoadedEditorAssemblies (318ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (77ms)
				ProcessInitializeOnLoadAttributes (161ms)
				ProcessInitializeOnLoadMethodAttributes (60ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.08 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6648.
Memory consumption went from 242.8 MB to 240.4 MB.
Total: 3.661600 ms (FindLiveObjects: 0.443500 ms CreateObjectMapping: 0.297100 ms MarkObjects: 2.283500 ms  DeleteObjects: 0.636100 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004717 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.02 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.852 seconds
Domain Reload Profiling:
	ReloadAssembly (853ms)
		BeginReloadAssembly (100ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (33ms)
		EndReloadAssembly (685ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (214ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (40ms)
			SetupLoadedEditorAssemblies (305ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (64ms)
				ProcessInitializeOnLoadAttributes (162ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.94 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6651.
Memory consumption went from 242.7 MB to 240.4 MB.
Total: 3.280000 ms (FindLiveObjects: 0.571400 ms CreateObjectMapping: 0.298300 ms MarkObjects: 1.822900 ms  DeleteObjects: 0.586100 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004702 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.75 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.830 seconds
Domain Reload Profiling:
	ReloadAssembly (831ms)
		BeginReloadAssembly (93ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (29ms)
		EndReloadAssembly (669ms)
			LoadAssemblies (58ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (211ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (300ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (61ms)
				ProcessInitializeOnLoadAttributes (160ms)
				ProcessInitializeOnLoadMethodAttributes (64ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.68 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6654.
Memory consumption went from 242.8 MB to 240.4 MB.
Total: 3.571700 ms (FindLiveObjects: 0.406400 ms CreateObjectMapping: 0.308000 ms MarkObjects: 2.199900 ms  DeleteObjects: 0.656400 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004777 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.72 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.823 seconds
Domain Reload Profiling:
	ReloadAssembly (823ms)
		BeginReloadAssembly (98ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (32ms)
		EndReloadAssembly (659ms)
			LoadAssemblies (60ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (197ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (307ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (70ms)
				ProcessInitializeOnLoadAttributes (160ms)
				ProcessInitializeOnLoadMethodAttributes (60ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.66 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6657.
Memory consumption went from 242.7 MB to 240.4 MB.
Total: 2.955100 ms (FindLiveObjects: 0.382700 ms CreateObjectMapping: 0.203000 ms MarkObjects: 1.850700 ms  DeleteObjects: 0.517400 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005356 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.75 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.804 seconds
Domain Reload Profiling:
	ReloadAssembly (805ms)
		BeginReloadAssembly (97ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (33ms)
		EndReloadAssembly (635ms)
			LoadAssemblies (53ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (187ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (34ms)
			SetupLoadedEditorAssemblies (298ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (65ms)
				ProcessInitializeOnLoadAttributes (155ms)
				ProcessInitializeOnLoadMethodAttributes (61ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.09 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6660.
Memory consumption went from 242.8 MB to 240.4 MB.
Total: 3.703200 ms (FindLiveObjects: 0.457500 ms CreateObjectMapping: 0.227400 ms MarkObjects: 2.255100 ms  DeleteObjects: 0.761900 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.006414 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.77 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.862 seconds
Domain Reload Profiling:
	ReloadAssembly (863ms)
		BeginReloadAssembly (103ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (693ms)
			LoadAssemblies (68ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (198ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (37ms)
			SetupLoadedEditorAssemblies (333ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (64ms)
				ProcessInitializeOnLoadAttributes (177ms)
				ProcessInitializeOnLoadMethodAttributes (75ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.78 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6663.
Memory consumption went from 242.7 MB to 240.4 MB.
Total: 3.385000 ms (FindLiveObjects: 0.474900 ms CreateObjectMapping: 0.297500 ms MarkObjects: 1.942600 ms  DeleteObjects: 0.668700 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005123 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.70 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.830 seconds
Domain Reload Profiling:
	ReloadAssembly (831ms)
		BeginReloadAssembly (88ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (26ms)
		EndReloadAssembly (664ms)
			LoadAssemblies (53ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (202ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (296ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (61ms)
				ProcessInitializeOnLoadAttributes (159ms)
				ProcessInitializeOnLoadMethodAttributes (60ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.89 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6666.
Memory consumption went from 242.8 MB to 240.4 MB.
Total: 3.461600 ms (FindLiveObjects: 0.430700 ms CreateObjectMapping: 0.236300 ms MarkObjects: 2.115900 ms  DeleteObjects: 0.677400 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.006088 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.86 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.812 seconds
Domain Reload Profiling:
	ReloadAssembly (812ms)
		BeginReloadAssembly (94ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (27ms)
		EndReloadAssembly (646ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (199ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (33ms)
			SetupLoadedEditorAssemblies (291ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (60ms)
				ProcessInitializeOnLoadAttributes (155ms)
				ProcessInitializeOnLoadMethodAttributes (60ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.29 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6669.
Memory consumption went from 242.8 MB to 240.4 MB.
Total: 3.591700 ms (FindLiveObjects: 0.397200 ms CreateObjectMapping: 0.215100 ms MarkObjects: 2.312300 ms  DeleteObjects: 0.665700 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004688 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.13 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.877 seconds
Domain Reload Profiling:
	ReloadAssembly (877ms)
		BeginReloadAssembly (97ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (6ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (705ms)
			LoadAssemblies (59ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (207ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (46ms)
			SetupLoadedEditorAssemblies (322ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (74ms)
				ProcessInitializeOnLoadAttributes (164ms)
				ProcessInitializeOnLoadMethodAttributes (63ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (16ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.86 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6672.
Memory consumption went from 242.8 MB to 240.4 MB.
Total: 3.376700 ms (FindLiveObjects: 0.433000 ms CreateObjectMapping: 0.261900 ms MarkObjects: 2.080000 ms  DeleteObjects: 0.600700 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004782 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.19 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.876 seconds
Domain Reload Profiling:
	ReloadAssembly (877ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (3ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (36ms)
		EndReloadAssembly (708ms)
			LoadAssemblies (52ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (207ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (345ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (73ms)
				ProcessInitializeOnLoadAttributes (180ms)
				ProcessInitializeOnLoadMethodAttributes (71ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.71 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6675.
Memory consumption went from 242.8 MB to 240.4 MB.
Total: 3.313900 ms (FindLiveObjects: 0.461000 ms CreateObjectMapping: 0.269700 ms MarkObjects: 1.877500 ms  DeleteObjects: 0.704500 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005220 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.05 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.812 seconds
Domain Reload Profiling:
	ReloadAssembly (812ms)
		BeginReloadAssembly (93ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (26ms)
		EndReloadAssembly (645ms)
			LoadAssemblies (58ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (191ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (305ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (62ms)
				ProcessInitializeOnLoadAttributes (158ms)
				ProcessInitializeOnLoadMethodAttributes (68ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.99 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6678.
Memory consumption went from 242.8 MB to 240.5 MB.
Total: 3.590700 ms (FindLiveObjects: 0.435300 ms CreateObjectMapping: 0.215000 ms MarkObjects: 2.164600 ms  DeleteObjects: 0.774300 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 2924.367495 seconds.
  path: Assets/Scenes/GameOver.unity
  artifactKey: Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/GameOver.unity using Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'cbed6d75636e8dc25d45c04c14a6f915') in 0.008511 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.006632 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.76 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.816 seconds
Domain Reload Profiling:
	ReloadAssembly (816ms)
		BeginReloadAssembly (96ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (3ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (27ms)
		EndReloadAssembly (653ms)
			LoadAssemblies (59ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (201ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (299ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (61ms)
				ProcessInitializeOnLoadAttributes (155ms)
				ProcessInitializeOnLoadMethodAttributes (67ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.91 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5863 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6681.
Memory consumption went from 242.9 MB to 240.5 MB.
Total: 3.538000 ms (FindLiveObjects: 0.394300 ms CreateObjectMapping: 0.223200 ms MarkObjects: 2.244500 ms  DeleteObjects: 0.674700 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 3684.867031 seconds.
  path: Assets/Scenes/GameOver.unity
  artifactKey: Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/GameOver.unity using Guid(1534b6e08125a014380c66a04c1fc8ca) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '8d6aa5f920251011fb200b29d2902882') in 0.011983 seconds 
========================================================================
Received Import Request.
  Time since last request: 1003.790054 seconds.
  path: Assets/Script(Control)
  artifactKey: Guid(87bf61c77395ed74a8ad1a1c582f3c70) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control) using Guid(87bf61c77395ed74a8ad1a1c582f3c70) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'ce7c89a16498f0ab10a8180db0975041') in 0.006464 seconds 
========================================================================
Received Import Request.
  Time since last request: 125.212774 seconds.
  path: Assets/Settings
  artifactKey: Guid(709f11a7f3c4041caa4ef136ea32d874) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Settings using Guid(709f11a7f3c4041caa4ef136ea32d874) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'cc1d78d26198bca73c008402c830304c') in 0.006384 seconds 
========================================================================
Received Import Request.
  Time since last request: 5.007418 seconds.
  path: Assets/Sprite/GameClear
  artifactKey: Guid(e7f684dbe6c2d451eb27adc1edace03d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameClear using Guid(e7f684dbe6c2d451eb27adc1edace03d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'eca7252bbff467dfff7b76920c0ad22d') in 0.006325 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.049809 seconds.
  path: Assets/Sprite/GameClear/1.png
  artifactKey: Guid(28e3a5f26072a4694874cf5e119e5da6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameClear/1.png using Guid(28e3a5f26072a4694874cf5e119e5da6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '9cf352052bd134c2eca94b3482c9f54f') in 0.068642 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000040 seconds.
  path: Assets/Sprite/GameClear/4.png
  artifactKey: Guid(8a7fe6f7d66154c18a774b9528fe6874) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameClear/4.png using Guid(8a7fe6f7d66154c18a774b9528fe6874) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'ba1541d7257daa4b3367761ee81a6019') in 0.023085 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000053 seconds.
  path: Assets/Sprite/GameClear/5.png
  artifactKey: Guid(e4d72974afd86475c8bcd33bde28d4c6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameClear/5.png using Guid(e4d72974afd86475c8bcd33bde28d4c6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '2adaa0516a8e685b0dc6f61edbe003d0') in 0.021013 seconds 
========================================================================
Received Import Request.
  Time since last request: 12.873019 seconds.
  path: Assets/Shaders
  artifactKey: Guid(cc72b7ac6f6ea7b4cbf92f92bbf2d246) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Shaders using Guid(cc72b7ac6f6ea7b4cbf92f92bbf2d246) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '91ab47813b4b681de062ec61bf84c2df') in 0.005613 seconds 
========================================================================
Received Import Request.
  Time since last request: 10.036920 seconds.
  path: Assets/Sprite/GameOver
  artifactKey: Guid(ddc8bb829db6a694e9196ff40bafe12f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameOver using Guid(ddc8bb829db6a694e9196ff40bafe12f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'ae7c5131c600e3a33f512a9d8621e232') in 0.005745 seconds 
========================================================================
Received Import Request.
  Time since last request: 77.626466 seconds.
  path: Assets/Sprite/GameOver/taigakutouka
  artifactKey: Guid(ae43dc84a85552940b390da1984b4dbf) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameOver/taigakutouka using Guid(ae43dc84a85552940b390da1984b4dbf) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '7546515a1f63e2c3216e1005086eb412') in 0.006676 seconds 
========================================================================
Received Import Request.
  Time since last request: 13.928202 seconds.
  path: Assets/Sprite/GameOver/taigaku.png
  artifactKey: Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameOver/taigaku.png using Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '2cdf0199da96a4d924e0b5ce2bac2fd7') in 0.019835 seconds 
========================================================================
Received Import Request.
  Time since last request: 22.559831 seconds.
  path: Assets/Sprite/GameOver/taigaku.png
  artifactKey: Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameOver/taigaku.png using Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'bd42f7bc25aa685cd16bdc51c7c5d69f') in 0.024741 seconds 
========================================================================
Received Import Request.
  Time since last request: 155.844697 seconds.
  path: Assets/Sprite/GameOver/taigaku.png
  artifactKey: Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameOver/taigaku.png using Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '8441c8a666172501ad849a1494b1ef05') in 0.015327 seconds 
========================================================================
Received Import Request.
  Time since last request: 6.340867 seconds.
  path: Assets/Sprite/GameOver/taigaku.png
  artifactKey: Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/GameOver/taigaku.png using Guid(d1f136799233b334cb8d0f658b55a7ee) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'd805a16118af2037dfe11dae9ea2a272') in 0.026545 seconds 
========================================================================
Received Import Request.
  Time since last request: 135.805808 seconds.
  path: Assets/Script(Control)/Opening
  artifactKey: Guid(a17b5c3dca9905040b6821270e4e70d2) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/Opening using Guid(a17b5c3dca9905040b6821270e4e70d2) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'bc990ca53994769ff0b521ee9c5f3eac') in 0.005757 seconds 
========================================================================
Received Import Request.
  Time since last request: 1.250683 seconds.
  path: Assets/Script(Control)/Unit 4
  artifactKey: Guid(9b489ef5fda11654481d273851b806e5) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/Unit 4 using Guid(9b489ef5fda11654481d273851b806e5) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'd394572beed18741328d34d57065c7d2') in 0.007259 seconds 
========================================================================
Received Import Request.
  Time since last request: 15.411587 seconds.
  path: Assets/Script(Control)/GameOver
  artifactKey: Guid(2612c7fafbaff524e9163806c336276a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/GameOver using Guid(2612c7fafbaff524e9163806c336276a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '27cde630006fe0ef48ab26b07031d078') in 0.005437 seconds 
========================================================================
Received Import Request.
  Time since last request: 4525.074482 seconds.
  path: Assets/Script(Control)/GameOver/Taigaku.cs
  artifactKey: Guid(eb55a26aa4b6b9547a5a9dfa6809f529) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/GameOver/Taigaku.cs using Guid(eb55a26aa4b6b9547a5a9dfa6809f529) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '09fa8468ef73076fb79b3b6678cee1b9') in 0.029949 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.006386 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.82 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.997 seconds
Domain Reload Profiling:
	ReloadAssembly (998ms)
		BeginReloadAssembly (157ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (7ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (62ms)
		EndReloadAssembly (755ms)
			LoadAssemblies (88ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (243ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (38ms)
			SetupLoadedEditorAssemblies (332ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (68ms)
				ProcessInitializeOnLoadAttributes (175ms)
				ProcessInitializeOnLoadMethodAttributes (73ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (17ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.21 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6697.
Memory consumption went from 242.9 MB to 240.5 MB.
Total: 4.142700 ms (FindLiveObjects: 0.623000 ms CreateObjectMapping: 0.273100 ms MarkObjects: 2.530200 ms  DeleteObjects: 0.715100 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004726 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.77 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.873 seconds
Domain Reload Profiling:
	ReloadAssembly (874ms)
		BeginReloadAssembly (97ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (28ms)
		EndReloadAssembly (705ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (226ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (320ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (66ms)
				ProcessInitializeOnLoadAttributes (171ms)
				ProcessInitializeOnLoadMethodAttributes (64ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.30 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6700.
Memory consumption went from 242.9 MB to 240.6 MB.
Total: 3.069900 ms (FindLiveObjects: 0.451300 ms CreateObjectMapping: 0.195800 ms MarkObjects: 1.890000 ms  DeleteObjects: 0.531800 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 211.932190 seconds.
  path: Assets/Script(Control)/GameOver/Taigaku.cs
  artifactKey: Guid(eb55a26aa4b6b9547a5a9dfa6809f529) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Script(Control)/GameOver/Taigaku.cs using Guid(eb55a26aa4b6b9547a5a9dfa6809f529) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '61c2e82198b7ac27e8dd0687b0d009a3') in 0.007951 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005087 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.73 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.880 seconds
Domain Reload Profiling:
	ReloadAssembly (881ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (709ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (218ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (39ms)
			SetupLoadedEditorAssemblies (325ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (67ms)
				ProcessInitializeOnLoadAttributes (175ms)
				ProcessInitializeOnLoadMethodAttributes (65ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.78 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6703.
Memory consumption went from 242.9 MB to 240.6 MB.
Total: 5.795500 ms (FindLiveObjects: 0.375900 ms CreateObjectMapping: 0.220300 ms MarkObjects: 4.635700 ms  DeleteObjects: 0.562000 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005087 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.70 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.868 seconds
Domain Reload Profiling:
	ReloadAssembly (869ms)
		BeginReloadAssembly (95ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (28ms)
		EndReloadAssembly (691ms)
			LoadAssemblies (58ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (212ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (37ms)
			SetupLoadedEditorAssemblies (316ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (66ms)
				ProcessInitializeOnLoadAttributes (170ms)
				ProcessInitializeOnLoadMethodAttributes (63ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.90 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6706.
Memory consumption went from 242.9 MB to 240.6 MB.
Total: 3.558200 ms (FindLiveObjects: 0.469100 ms CreateObjectMapping: 0.225700 ms MarkObjects: 2.107200 ms  DeleteObjects: 0.754200 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 318.310673 seconds.
  path: Assets/SE
  artifactKey: Guid(34605363376689d4f81a0a7c95c90444) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/SE using Guid(34605363376689d4f81a0a7c95c90444) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'f2c86e90747c258c12a268ee67317036') in 0.014761 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000031 seconds.
  path: Assets/SE/closewindow.mp3
  artifactKey: Guid(b885900af2323eb4d84e16a9720ab97d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/SE/closewindow.mp3 using Guid(b885900af2323eb4d84e16a9720ab97d) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'a8b654fe187cbf4a22c3aa98218339cb') in 0.061557 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000033 seconds.
  path: Assets/SE/openwindow.wav
  artifactKey: Guid(4dc74517541ab1244ad89a818138f2b6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/SE/openwindow.wav using Guid(4dc74517541ab1244ad89a818138f2b6) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '9de910b90c5736fd7e5a42a669d889a7') in 0.015017 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000029 seconds.
  path: Assets/SE/select2.mp3
  artifactKey: Guid(91855176897cf6047a7f19715bc8db05) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/SE/select2.mp3 using Guid(91855176897cf6047a7f19715bc8db05) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'e468ca2f06445d5f968d0fa3254d794a') in 0.017347 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005463 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.78 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.997 seconds
Domain Reload Profiling:
	ReloadAssembly (997ms)
		BeginReloadAssembly (136ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (55ms)
		EndReloadAssembly (786ms)
			LoadAssemblies (77ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (239ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (41ms)
			SetupLoadedEditorAssemblies (366ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (74ms)
				ProcessInitializeOnLoadAttributes (202ms)
				ProcessInitializeOnLoadMethodAttributes (71ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 3.13 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6711.
Memory consumption went from 243.0 MB to 240.6 MB.
Total: 6.126700 ms (FindLiveObjects: 0.650700 ms CreateObjectMapping: 0.459900 ms MarkObjects: 4.083800 ms  DeleteObjects: 0.930700 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005946 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.74 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.872 seconds
Domain Reload Profiling:
	ReloadAssembly (872ms)
		BeginReloadAssembly (104ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (33ms)
		EndReloadAssembly (698ms)
			LoadAssemblies (64ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (221ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (37ms)
			SetupLoadedEditorAssemblies (317ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (73ms)
				ProcessInitializeOnLoadAttributes (161ms)
				ProcessInitializeOnLoadMethodAttributes (64ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.17 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6714.
Memory consumption went from 243.0 MB to 240.6 MB.
Total: 3.124300 ms (FindLiveObjects: 0.357100 ms CreateObjectMapping: 0.191100 ms MarkObjects: 1.970800 ms  DeleteObjects: 0.604000 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005187 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.83 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.895 seconds
Domain Reload Profiling:
	ReloadAssembly (896ms)
		BeginReloadAssembly (95ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (29ms)
		EndReloadAssembly (717ms)
			LoadAssemblies (57ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (232ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (37ms)
			SetupLoadedEditorAssemblies (321ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (68ms)
				ProcessInitializeOnLoadAttributes (171ms)
				ProcessInitializeOnLoadMethodAttributes (65ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.07 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6717.
Memory consumption went from 243.0 MB to 240.7 MB.
Total: 3.750300 ms (FindLiveObjects: 0.450500 ms CreateObjectMapping: 0.226300 ms MarkObjects: 2.351800 ms  DeleteObjects: 0.719800 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005042 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.80 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.850 seconds
Domain Reload Profiling:
	ReloadAssembly (850ms)
		BeginReloadAssembly (97ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (29ms)
		EndReloadAssembly (676ms)
			LoadAssemblies (58ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (203ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (45ms)
			SetupLoadedEditorAssemblies (301ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (62ms)
				ProcessInitializeOnLoadAttributes (161ms)
				ProcessInitializeOnLoadMethodAttributes (61ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.77 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6720.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 3.372700 ms (FindLiveObjects: 0.377000 ms CreateObjectMapping: 0.268900 ms MarkObjects: 2.173900 ms  DeleteObjects: 0.551600 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005509 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.72 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.898 seconds
Domain Reload Profiling:
	ReloadAssembly (898ms)
		BeginReloadAssembly (114ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (37ms)
		EndReloadAssembly (709ms)
			LoadAssemblies (73ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (208ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (42ms)
			SetupLoadedEditorAssemblies (324ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (75ms)
				ProcessInitializeOnLoadAttributes (170ms)
				ProcessInitializeOnLoadMethodAttributes (61ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 3.03 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6723.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 5.739900 ms (FindLiveObjects: 0.739700 ms CreateObjectMapping: 0.384100 ms MarkObjects: 3.751900 ms  DeleteObjects: 0.861900 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005099 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.78 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.874 seconds
Domain Reload Profiling:
	ReloadAssembly (875ms)
		BeginReloadAssembly (110ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (41ms)
		EndReloadAssembly (684ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (212ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (38ms)
			SetupLoadedEditorAssemblies (308ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (65ms)
				ProcessInitializeOnLoadAttributes (162ms)
				ProcessInitializeOnLoadMethodAttributes (64ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.71 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6726.
Memory consumption went from 243.0 MB to 240.7 MB.
Total: 3.221700 ms (FindLiveObjects: 0.333400 ms CreateObjectMapping: 0.219400 ms MarkObjects: 2.009700 ms  DeleteObjects: 0.657800 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004747 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.93 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.872 seconds
Domain Reload Profiling:
	ReloadAssembly (873ms)
		BeginReloadAssembly (106ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (31ms)
		EndReloadAssembly (693ms)
			LoadAssemblies (66ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (213ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (38ms)
			SetupLoadedEditorAssemblies (315ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (68ms)
				ProcessInitializeOnLoadAttributes (167ms)
				ProcessInitializeOnLoadMethodAttributes (63ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.00 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6729.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 3.345400 ms (FindLiveObjects: 0.414600 ms CreateObjectMapping: 0.243900 ms MarkObjects: 2.090800 ms  DeleteObjects: 0.595000 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004889 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.72 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.837 seconds
Domain Reload Profiling:
	ReloadAssembly (838ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (32ms)
		EndReloadAssembly (669ms)
			LoadAssemblies (62ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (208ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (39ms)
			SetupLoadedEditorAssemblies (298ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (63ms)
				ProcessInitializeOnLoadAttributes (155ms)
				ProcessInitializeOnLoadMethodAttributes (61ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.47 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6732.
Memory consumption went from 243.0 MB to 240.7 MB.
Total: 4.384400 ms (FindLiveObjects: 0.513700 ms CreateObjectMapping: 0.254300 ms MarkObjects: 2.656800 ms  DeleteObjects: 0.958400 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.007389 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.74 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.865 seconds
Domain Reload Profiling:
	ReloadAssembly (866ms)
		BeginReloadAssembly (109ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (3ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (36ms)
		EndReloadAssembly (686ms)
			LoadAssemblies (64ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (205ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (318ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (63ms)
				ProcessInitializeOnLoadAttributes (174ms)
				ProcessInitializeOnLoadMethodAttributes (64ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (16ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.78 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6735.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 4.261200 ms (FindLiveObjects: 0.361700 ms CreateObjectMapping: 0.203800 ms MarkObjects: 2.936300 ms  DeleteObjects: 0.758000 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004846 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.21 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.863 seconds
Domain Reload Profiling:
	ReloadAssembly (864ms)
		BeginReloadAssembly (94ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (29ms)
		EndReloadAssembly (700ms)
			LoadAssemblies (56ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (219ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (323ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (68ms)
				ProcessInitializeOnLoadAttributes (169ms)
				ProcessInitializeOnLoadMethodAttributes (66ms)
				AfterProcessingInitializeOnLoad (8ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.13 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6738.
Memory consumption went from 243.0 MB to 240.7 MB.
Total: 3.209800 ms (FindLiveObjects: 0.459400 ms CreateObjectMapping: 0.208500 ms MarkObjects: 1.988800 ms  DeleteObjects: 0.551900 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005985 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.89 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.875 seconds
Domain Reload Profiling:
	ReloadAssembly (875ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (31ms)
		EndReloadAssembly (707ms)
			LoadAssemblies (60ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (223ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (34ms)
			SetupLoadedEditorAssemblies (322ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (71ms)
				ProcessInitializeOnLoadAttributes (171ms)
				ProcessInitializeOnLoadMethodAttributes (63ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.49 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6741.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 5.057400 ms (FindLiveObjects: 0.650500 ms CreateObjectMapping: 0.269000 ms MarkObjects: 3.399200 ms  DeleteObjects: 0.736500 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005334 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.83 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.865 seconds
Domain Reload Profiling:
	ReloadAssembly (866ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (683ms)
			LoadAssemblies (58ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (219ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (39ms)
			SetupLoadedEditorAssemblies (304ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (62ms)
				ProcessInitializeOnLoadAttributes (162ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.84 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6744.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 3.466300 ms (FindLiveObjects: 0.433200 ms CreateObjectMapping: 0.221100 ms MarkObjects: 2.223300 ms  DeleteObjects: 0.587500 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005289 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.78 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.880 seconds
Domain Reload Profiling:
	ReloadAssembly (880ms)
		BeginReloadAssembly (97ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (28ms)
		EndReloadAssembly (707ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (210ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (51ms)
			SetupLoadedEditorAssemblies (317ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (65ms)
				ProcessInitializeOnLoadAttributes (168ms)
				ProcessInitializeOnLoadMethodAttributes (64ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.96 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6747.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 4.587600 ms (FindLiveObjects: 0.763800 ms CreateObjectMapping: 0.432200 ms MarkObjects: 2.385500 ms  DeleteObjects: 1.004400 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005262 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.84 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.895 seconds
Domain Reload Profiling:
	ReloadAssembly (895ms)
		BeginReloadAssembly (117ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (6ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (45ms)
		EndReloadAssembly (708ms)
			LoadAssemblies (65ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (226ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (42ms)
			SetupLoadedEditorAssemblies (310ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (63ms)
				ProcessInitializeOnLoadAttributes (168ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.17 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6750.
Memory consumption went from 243.1 MB to 240.7 MB.
Total: 2.767500 ms (FindLiveObjects: 0.331000 ms CreateObjectMapping: 0.183300 ms MarkObjects: 1.782300 ms  DeleteObjects: 0.470300 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005139 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.05 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.872 seconds
Domain Reload Profiling:
	ReloadAssembly (873ms)
		BeginReloadAssembly (94ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (27ms)
		EndReloadAssembly (703ms)
			LoadAssemblies (56ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (208ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (45ms)
			SetupLoadedEditorAssemblies (323ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (64ms)
				ProcessInitializeOnLoadAttributes (170ms)
				ProcessInitializeOnLoadMethodAttributes (72ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 3.06 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6753.
Memory consumption went from 243.2 MB to 240.8 MB.
Total: 5.631200 ms (FindLiveObjects: 0.811500 ms CreateObjectMapping: 0.399000 ms MarkObjects: 3.416700 ms  DeleteObjects: 1.002600 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005347 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.91 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.900 seconds
Domain Reload Profiling:
	ReloadAssembly (900ms)
		BeginReloadAssembly (110ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (36ms)
		EndReloadAssembly (700ms)
			LoadAssemblies (65ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (209ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (38ms)
			SetupLoadedEditorAssemblies (328ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (67ms)
				ProcessInitializeOnLoadAttributes (177ms)
				ProcessInitializeOnLoadMethodAttributes (66ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.90 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6756.
Memory consumption went from 243.2 MB to 240.8 MB.
Total: 3.092100 ms (FindLiveObjects: 0.330000 ms CreateObjectMapping: 0.183500 ms MarkObjects: 1.813900 ms  DeleteObjects: 0.763200 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004792 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.74 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.878 seconds
Domain Reload Profiling:
	ReloadAssembly (878ms)
		BeginReloadAssembly (104ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (29ms)
		EndReloadAssembly (702ms)
			LoadAssemblies (68ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (206ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (37ms)
			SetupLoadedEditorAssemblies (325ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (64ms)
				ProcessInitializeOnLoadAttributes (177ms)
				ProcessInitializeOnLoadMethodAttributes (68ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.90 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6759.
Memory consumption went from 243.1 MB to 240.8 MB.
Total: 3.520900 ms (FindLiveObjects: 0.356200 ms CreateObjectMapping: 0.198900 ms MarkObjects: 2.359100 ms  DeleteObjects: 0.605100 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004714 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.78 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.874 seconds
Domain Reload Profiling:
	ReloadAssembly (875ms)
		BeginReloadAssembly (102ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (700ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (215ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (321ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (70ms)
				ProcessInitializeOnLoadAttributes (171ms)
				ProcessInitializeOnLoadMethodAttributes (62ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.24 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6762.
Memory consumption went from 243.1 MB to 240.8 MB.
Total: 5.122000 ms (FindLiveObjects: 0.629700 ms CreateObjectMapping: 0.744500 ms MarkObjects: 2.734700 ms  DeleteObjects: 1.011200 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005245 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.19 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.909 seconds
Domain Reload Profiling:
	ReloadAssembly (910ms)
		BeginReloadAssembly (115ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (41ms)
		EndReloadAssembly (716ms)
			LoadAssemblies (70ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (210ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (42ms)
			SetupLoadedEditorAssemblies (327ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (73ms)
				ProcessInitializeOnLoadAttributes (170ms)
				ProcessInitializeOnLoadMethodAttributes (65ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.20 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6765.
Memory consumption went from 243.2 MB to 240.8 MB.
Total: 4.199700 ms (FindLiveObjects: 0.585900 ms CreateObjectMapping: 0.346500 ms MarkObjects: 2.411100 ms  DeleteObjects: 0.854600 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005496 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.80 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.921 seconds
Domain Reload Profiling:
	ReloadAssembly (921ms)
		BeginReloadAssembly (125ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (51ms)
		EndReloadAssembly (715ms)
			LoadAssemblies (65ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (215ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (34ms)
			SetupLoadedEditorAssemblies (340ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (66ms)
				ProcessInitializeOnLoadAttributes (183ms)
				ProcessInitializeOnLoadMethodAttributes (74ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.74 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6768.
Memory consumption went from 243.2 MB to 240.8 MB.
Total: 3.026400 ms (FindLiveObjects: 0.331400 ms CreateObjectMapping: 0.187300 ms MarkObjects: 1.905100 ms  DeleteObjects: 0.601500 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.006154 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.80 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.878 seconds
Domain Reload Profiling:
	ReloadAssembly (878ms)
		BeginReloadAssembly (104ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (33ms)
		EndReloadAssembly (702ms)
			LoadAssemblies (62ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (206ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (38ms)
			SetupLoadedEditorAssemblies (330ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (63ms)
				ProcessInitializeOnLoadAttributes (181ms)
				ProcessInitializeOnLoadMethodAttributes (68ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (16ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.60 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6771.
Memory consumption went from 243.2 MB to 240.8 MB.
Total: 3.207300 ms (FindLiveObjects: 0.666300 ms CreateObjectMapping: 0.196900 ms MarkObjects: 1.786600 ms  DeleteObjects: 0.556400 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.006329 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.73 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.873 seconds
Domain Reload Profiling:
	ReloadAssembly (874ms)
		BeginReloadAssembly (105ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (7ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (29ms)
		EndReloadAssembly (697ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (217ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (35ms)
			SetupLoadedEditorAssemblies (322ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (64ms)
				ProcessInitializeOnLoadAttributes (175ms)
				ProcessInitializeOnLoadMethodAttributes (65ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.83 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6774.
Memory consumption went from 243.2 MB to 240.8 MB.
Total: 4.312300 ms (FindLiveObjects: 0.408900 ms CreateObjectMapping: 0.246300 ms MarkObjects: 2.899700 ms  DeleteObjects: 0.756200 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005211 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.88 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.886 seconds
Domain Reload Profiling:
	ReloadAssembly (886ms)
		BeginReloadAssembly (100ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (31ms)
		EndReloadAssembly (715ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (223ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (37ms)
			SetupLoadedEditorAssemblies (327ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (68ms)
				ProcessInitializeOnLoadAttributes (170ms)
				ProcessInitializeOnLoadMethodAttributes (72ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.32 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6777.
Memory consumption went from 243.2 MB to 240.9 MB.
Total: 3.217300 ms (FindLiveObjects: 0.366600 ms CreateObjectMapping: 0.216000 ms MarkObjects: 2.086200 ms  DeleteObjects: 0.547300 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.007334 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.79 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.879 seconds
Domain Reload Profiling:
	ReloadAssembly (879ms)
		BeginReloadAssembly (107ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (37ms)
		EndReloadAssembly (692ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (219ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (40ms)
			SetupLoadedEditorAssemblies (307ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (65ms)
				ProcessInitializeOnLoadAttributes (163ms)
				ProcessInitializeOnLoadMethodAttributes (60ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.93 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6780.
Memory consumption went from 243.2 MB to 240.9 MB.
Total: 2.906500 ms (FindLiveObjects: 0.352300 ms CreateObjectMapping: 0.177300 ms MarkObjects: 1.848800 ms  DeleteObjects: 0.527100 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005283 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.71 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.880 seconds
Domain Reload Profiling:
	ReloadAssembly (880ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (28ms)
		EndReloadAssembly (703ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (207ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (336ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (72ms)
				ProcessInitializeOnLoadAttributes (180ms)
				ProcessInitializeOnLoadMethodAttributes (68ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.31 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6783.
Memory consumption went from 243.2 MB to 240.9 MB.
Total: 4.489400 ms (FindLiveObjects: 0.745100 ms CreateObjectMapping: 0.576700 ms MarkObjects: 2.555300 ms  DeleteObjects: 0.610300 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005114 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.05 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.850 seconds
Domain Reload Profiling:
	ReloadAssembly (850ms)
		BeginReloadAssembly (101ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (30ms)
		EndReloadAssembly (677ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (215ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (36ms)
			SetupLoadedEditorAssemblies (301ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (65ms)
				ProcessInitializeOnLoadAttributes (159ms)
				ProcessInitializeOnLoadMethodAttributes (60ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (12ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.76 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.4 MB). Loaded Objects now: 6786.
Memory consumption went from 243.3 MB to 240.9 MB.
Total: 3.557600 ms (FindLiveObjects: 0.417700 ms CreateObjectMapping: 0.351400 ms MarkObjects: 2.234300 ms  DeleteObjects: 0.553100 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005151 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 1.14 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.870 seconds
Domain Reload Profiling:
	ReloadAssembly (871ms)
		BeginReloadAssembly (96ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (28ms)
		EndReloadAssembly (701ms)
			LoadAssemblies (57ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (213ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (42ms)
			SetupLoadedEditorAssemblies (319ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (66ms)
				ProcessInitializeOnLoadAttributes (168ms)
				ProcessInitializeOnLoadMethodAttributes (66ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 1.92 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6789.
Memory consumption went from 243.2 MB to 240.9 MB.
Total: 4.125900 ms (FindLiveObjects: 0.456600 ms CreateObjectMapping: 0.508400 ms MarkObjects: 2.512300 ms  DeleteObjects: 0.647400 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004751 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.81 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.922 seconds
Domain Reload Profiling:
	ReloadAssembly (923ms)
		BeginReloadAssembly (108ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (5ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (36ms)
		EndReloadAssembly (735ms)
			LoadAssemblies (63ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (217ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (43ms)
			SetupLoadedEditorAssemblies (345ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (68ms)
				ProcessInitializeOnLoadAttributes (197ms)
				ProcessInitializeOnLoadMethodAttributes (63ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.02 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6792.
Memory consumption went from 243.2 MB to 240.9 MB.
Total: 3.198500 ms (FindLiveObjects: 0.340600 ms CreateObjectMapping: 0.182600 ms MarkObjects: 2.166000 ms  DeleteObjects: 0.508300 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:framework-win-MediaFoundation: 216162199b28c13a410421893ffa2e32 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005710 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\YamlDotNet\Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image C:\Users\kuma\Documents\GitHub\ADU\ADU\Library\PackageCache\com.unity.visualscripting@1.7.6\Editor\VisualScripting.Core\Dependencies\DotNetZip\Unity.VisualScripting.IonicZip.dll
Native extension for WindowsStandalone target not found
Refreshing native plugins compatible for Editor in 0.79 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  0.885 seconds
Domain Reload Profiling:
	ReloadAssembly (886ms)
		BeginReloadAssembly (99ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (4ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (27ms)
		EndReloadAssembly (711ms)
			LoadAssemblies (61ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (209ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (38ms)
			SetupLoadedEditorAssemblies (333ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (9ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (67ms)
				ProcessInitializeOnLoadAttributes (166ms)
				ProcessInitializeOnLoadMethodAttributes (82ms)
				AfterProcessingInitializeOnLoad (7ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Refreshing native plugins compatible for Editor in 2.61 ms, found 3 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5864 Unused Serialized files (Serialized files now loaded: 0)
Unloading 44 unused Assets / (2.3 MB). Loaded Objects now: 6795.
Memory consumption went from 243.3 MB to 240.9 MB.
Total: 5.077200 ms (FindLiveObjects: 0.501200 ms CreateObjectMapping: 0.445700 ms MarkObjects: 2.799000 ms  DeleteObjects: 1.329700 ms)
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003112 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.66 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.430 seconds
Domain Reload Profiling:
	ReloadAssembly (2431ms)
		BeginReloadAssembly (450ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (24ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (228ms)
		EndReloadAssembly (1803ms)
			LoadAssemblies (264ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (618ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (96ms)
			SetupLoadedEditorAssemblies (719ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (12ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (114ms)
				ProcessInitializeOnLoadAttributes (431ms)
				ProcessInitializeOnLoadMethodAttributes (156ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (30ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 4.34 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6637.
Memory consumption went from 382.1 MB to 379.6 MB.
Total: 7.524051 ms (FindLiveObjects: 0.662046 ms CreateObjectMapping: 0.565135 ms MarkObjects: 5.016719 ms  DeleteObjects: 1.278672 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.002998 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/mst/Documents/GitHub/ADU/ADU/Library/PackageCache/com.unity.visualscripting@1.7.6/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Refreshing native plugins compatible for Editor in 1.38 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.182 seconds
Domain Reload Profiling:
	ReloadAssembly (2186ms)
		BeginReloadAssembly (352ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (21ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (198ms)
		EndReloadAssembly (1666ms)
			LoadAssemblies (134ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (617ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (93ms)
			SetupLoadedEditorAssemblies (661ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (13ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (106ms)
				ProcessInitializeOnLoadAttributes (395ms)
				ProcessInitializeOnLoadMethodAttributes (142ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (30ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:345:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    float u_xlat14;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat14 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat14) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:344:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:345:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat0 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    output.mtl_Position = u_xlat0;
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat0.zw;
    output.TEXCOORD2.xy = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:336:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:340:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:341:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat8;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat2);
    u_xlat3.xyz = fma((-u_xlat2.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat12 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat3.xyz);
    u_xlat12 = fma((-u_xlat12), u_xlat12, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat12 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat12), u_xlat2.xyz);
    u_xlatb12 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb12)) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat0);
    u_xlat2.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat2.x = min(u_xlat2.x, 0.0);
    u_xlat2.x = max(u_xlat2.x, -1.0);
    u_xlat8 = u_xlat0.z + u_xlat2.x;
    u_xlat2.x = min(u_xlat0.w, u_xlat8);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat8) + u_xlat2.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat8);
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:347:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:348:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat4;
    float u_xlat12;
    u_xlat0.x = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4 = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat0.x = (-u_xlat0.x) + u_xlat4;
    u_xlat0.xyz = fma((-input.cp[1].NORMAL0.xyz), u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat0.xyz = fma(float3(VGlobals._Smoothness), u_xlat0.xyz, u_xlat1.xyz);
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat2);
    u_xlat2 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    u_xlat1 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat1);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:346:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:350:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:351:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Smoothness;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool2 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool u_xlatb6;
    float2 u_xlat11;
    bool2 u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat17;
    bool u_xlatb17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.x = -0.0<u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.y = -0.0<u_xlat6.x;
        u_xlat1.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xy));
        u_xlat1.x = u_xlat1.y + u_xlat1.x;
        u_xlat6.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat6.xyz);
        u_xlat6.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat6.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat6.xyz);
        u_xlat3.w = 1.0;
        u_xlat6.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb6 = -0.0<u_xlat6.x;
        u_xlat1.y = u_xlatb6 ? 1.0 : float(0.0);
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat1.zw = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat1.xz = u_xlat1.yw + u_xlat1.xz;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb16 = -0.0<u_xlat16;
        u_xlat16 = u_xlatb16 ? 1.0 : float(0.0);
        u_xlat1.y = u_xlat16 + u_xlat1.z;
        u_xlat11.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = -0.0<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb11.x = -0.0<u_xlat11.x;
        u_xlat16 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat15 = u_xlat15 + u_xlat17;
        u_xlatb11.y = -0.0<u_xlat16;
        u_xlat11.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb11.xy));
        u_xlat11.x = u_xlat11.y + u_xlat11.x;
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat17 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb17 = -0.0<u_xlat17;
        u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat15 + u_xlat17;
        u_xlatb15 = -0.0<u_xlat16;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat15 + u_xlat11.x;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    float u_xlat14;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat12 = dot(input.cp[1].INTERNALTESSPOS0.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.x = dot(u_xlat1.xyz, input.cp[1].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat2.x;
    u_xlat2.xyz = fma((-input.cp[1].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = u_xlat2.xyz * mtl_TessCoord.yyy;
    u_xlat12 = dot(input.cp[0].INTERNALTESSPOS0.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[0].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[0].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat12 = dot(input.cp[2].INTERNALTESSPOS0.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat14 = dot(u_xlat1.xyz, input.cp[2].NORMAL0.xyz);
    u_xlat12 = (-u_xlat12) + u_xlat14;
    u_xlat3.xyz = fma((-input.cp[2].NORMAL0.xyz), float3(u_xlat12), u_xlat1.xyz);
    u_xlat2.xyz = fma(u_xlat3.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat12 = (-VGlobals._Smoothness) + 1.0;
    u_xlat1.xyz = u_xlat1.xyz * float3(u_xlat12);
    u_xlat1.xyz = fma(float3(VGlobals._Smoothness), u_xlat2.xyz, u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat3 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat3 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xy = fma(u_xlat3.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.z = u_xlat1.y;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:342:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:348:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:349:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    float u_xlat12;
    float u_xlat18;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = fma(u_xlat2.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlat3 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat5);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat5);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat18 = rsqrt(u_xlat18);
    u_xlat0.xyz = float3(u_xlat18) * u_xlat0.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat1.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat1.xyz);
    u_xlat18 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat2.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat2.x = rsqrt(u_xlat2.x);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xxx;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2.xyz = fma(u_xlat0.zxy, u_xlat1.yzx, (-u_xlat2.xyz));
    u_xlat2.xyz = float3(u_xlat18) * u_xlat2.xyz;
    output.TEXCOORD1.y = u_xlat2.x;
    output.TEXCOORD1.x = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat1.x;
    output.TEXCOORD3.x = u_xlat1.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat2.y;
    output.TEXCOORD3.y = u_xlat2.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat3.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat1.wwww, u_xlat3);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:337:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:343:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:344:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _BumpMap_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float3 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    float u_xlat12;
    float u_xlat13;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat2 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat2);
    u_xlat2.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat0.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat0.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat1.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat1.y;
    output.TEXCOORD3.w = u_xlat1.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat0.z;
    output.TEXCOORD3.z = u_xlat0.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:339:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:345:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:346:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat8;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat8 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat0.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat0.x = u_xlat8 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat1.xyz = fma(u_xlat4.xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.zzzz, u_xlat2);
    u_xlat3 = u_xlat2 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat2.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    output.mtl_Position = u_xlat1;
    u_xlat0.x = u_xlat1.y * VGlobals._ProjectionParams.x;
    u_xlat2.w = u_xlat0.x * 0.5;
    u_xlat2.xz = u_xlat1.xw * float2(0.5, 0.5);
    output.TEXCOORD2.zw = u_xlat1.zw;
    output.TEXCOORD2.xy = u_xlat2.zz + u_xlat2.xw;
    output.TEXCOORD3 = float4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = fma(u_xlat0.x, u_xlat0.x, (-u_xlat1.x));
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat3.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat3.z = dot(VGlobals.unity_SHBb, u_xlat2);
    u_xlat1.xyz = fma(VGlobals.unity_SHC.xyz, u_xlat1.xxx, u_xlat3.xyz);
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(VGlobals.unity_SHAr, u_xlat0);
    u_xlat2.y = dot(VGlobals.unity_SHAg, u_xlat0);
    u_xlat2.z = dot(VGlobals.unity_SHAb, u_xlat0);
    output.TEXCOORD4.xyz = u_xlat1.xyz + u_xlat2.xyz;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:333:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:339:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:340:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat15 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat2.xy, level(0.0)).w;
    u_xlat15 = u_xlat15 * VGlobals._Parallax;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(u_xlat15), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:340:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:346:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:347:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    float4 _MainTex_ST;
    float4 _BumpMap_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    float u_xlat16;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat11 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    u_xlat11 = u_xlat11 * VGlobals._Parallax;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat0.xyz = fma(u_xlat2.xyz, float3(u_xlat11), u_xlat0.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat4 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat3.xyz);
    u_xlat3 = u_xlat4.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat4.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat4.zzzz, u_xlat3);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat4.wwww, u_xlat3);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._BumpMap_ST.xy, VGlobals._BumpMap_ST.zw);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat15 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat2.xyz = float3(u_xlat16) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat15) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:343:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:349:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:350:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xy = input.TEXCOORD1.xy;
    output.TEXCOORD2.xy = input.TEXCOORD2.xy;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(6) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
    float2 TEXCOORD2 [[ attribute(5) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _EdgeLength;
    float _Parallax;
    float4 _Color;
    float _Shininess;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _MainTex_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float4 u_xlat0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    float3 u_xlat4;
    float u_xlat5;
    float3 u_xlat6;
    bool3 u_xlatb6;
    float2 u_xlat11;
    bool u_xlatb11;
    float u_xlat15;
    bool u_xlatb15;
    float u_xlat16;
    float u_xlat17;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat0.w = 1.0;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlat6.x = VGlobals._Parallax * 1.5;
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat2.w = 1.0;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat3.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat3.xyz);
        u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat3.xyz);
        u_xlat3.w = 1.0;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[0]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.x = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb1.z = (-u_xlat6.x)<u_xlat11.x;
        u_xlat1.xz = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb1.xz));
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[1]);
        u_xlatb11 = (-u_xlat6.x)<u_xlat11.x;
        u_xlat11.x = u_xlatb11 ? 1.0 : float(0.0);
        u_xlat4.y = u_xlat11.x + u_xlat1.x;
        u_xlat1.x = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat15 = dot(u_xlat0, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb15 = (-u_xlat6.x)<u_xlat15;
        u_xlat15 = u_xlatb15 ? 1.0 : float(0.0);
        u_xlatb1.x = (-u_xlat6.x)<u_xlat1.x;
        u_xlat11.x = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat11.y = dot(u_xlat2, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb1.zw = ((-u_xlat6.xx)<u_xlat11.xy);
        u_xlat1.xzw = select(float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0), bool3(u_xlatb1.xzw));
        u_xlat15 = u_xlat15 + u_xlat1.w;
        u_xlat1.x = u_xlat1.z + u_xlat1.x;
        u_xlat11.x = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[2]);
        u_xlat16 = dot(u_xlat3, VGlobals.unity_CameraWorldClipPlanes[3]);
        u_xlatb6.z = (-u_xlat6.x)<u_xlat16;
        u_xlatb6.x = (-u_xlat6.x)<u_xlat11.x;
        u_xlat6.xy = select(float2(0.0, 0.0), float2(1.0, 1.0), bool2(u_xlatb6.xz));
        u_xlat1.x = u_xlat6.x + u_xlat1.x;
        u_xlat1.y = u_xlat15 + u_xlat6.y;
        u_xlat1.xy = u_xlat1.xy * u_xlat4.xy;
        u_xlat15 = u_xlat1.y * u_xlat1.x;
        u_xlatb15 = u_xlat15==0.0;
        u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat6.xyz = u_xlat2.xyz + (-u_xlat3.xyz);
        u_xlat6.x = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat6.x = sqrt(u_xlat6.x);
        u_xlat6.x = u_xlat6.x * VGlobals._ScreenParams.y;
        u_xlat1.x = u_xlat6.x / u_xlat1.x;
        u_xlat1.x = max(u_xlat1.x, 1.0);
        u_xlat4.xyz = u_xlat0.xyz + u_xlat3.xyz;
        u_xlat3.xyz = (-u_xlat0.xyz) + u_xlat3.xyz;
        u_xlat17 = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat17 = sqrt(u_xlat17);
        u_xlat17 = u_xlat17 * VGlobals._ScreenParams.y;
        u_xlat3.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
        u_xlat3.x = sqrt(u_xlat3.x);
        u_xlat3.x = u_xlat3.x * VGlobals._EdgeLength;
        u_xlat17 = u_xlat17 / u_xlat3.x;
        u_xlat1.y = max(u_xlat17, 1.0);
        u_xlat17 = u_xlat1.y + u_xlat1.x;
        u_xlat3.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-u_xlat2.xyz);
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat2.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat5 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat5 = sqrt(u_xlat5);
        u_xlat5 = u_xlat5 * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat5;
        u_xlat1.z = max(u_xlat0.x, 1.0);
        u_xlat0.x = u_xlat1.z + u_xlat17;
        u_xlat1.w = u_xlat0.x * 0.333333343;
        u_xlat0 = (bool(u_xlatb15)) ? float4(0.0, 0.0, 0.0, 0.0) : u_xlat1;
        tessFactor.edgeTessellationFactor[0] = u_xlat0.x;
        tessFactor.edgeTessellationFactor[1] = u_xlat0.y;
        tessFactor.edgeTessellationFactor[2] = u_xlat0.z;
        tessFactor.insideTessellationFactor = u_xlat0.w;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ParallaxMap [[ sampler (0) ]],
    texture2d<float, access::sample > _ParallaxMap [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
        float4 phase0_Input0_3[3];
        phase0_Input0_3[2] = float4(input.cp[2].TEXCOORD0, input.cp[2].TEXCOORD1);
        phase0_Input0_3[1] = float4(input.cp[1].TEXCOORD0, input.cp[1].TEXCOORD1);
        phase0_Input0_3[0] = float4(input.cp[0].TEXCOORD0, input.cp[0].TEXCOORD1);
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1 = mtl_TessCoord.yyyy * phase0_Input0_3[1];
    u_xlat1 = fma(phase0_Input0_3[0], mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(phase0_Input0_3[2], mtl_TessCoord.zzzz, u_xlat1);
    u_xlat2.xy = fma(u_xlat1.zw, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat12 = _ParallaxMap.sample(sampler_ParallaxMap, u_xlat1.xy, level(0.0)).w;
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    u_xlat12 = u_xlat12 * VGlobals._Parallax;
    u_xlat1 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat1 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat1);
    u_xlat1 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat1);
    u_xlat3.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat3.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat3.xyz);
    u_xlat3.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat3.xyz);
    u_xlat1.xyz = fma(u_xlat3.xyz, float3(u_xlat12), u_xlat1.xyz);
    u_xlatb12 = 0.0<u_xlat1.z;
    u_xlat2.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat2.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat2.xyz : u_xlat1.xyz;
    u_xlatb12 = 0.0<u_xlat2.z;
    u_xlat0.z = u_xlatb12 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat2.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat1.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat1.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat1.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat1.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat3.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat2.xyz = float3(u_xlat12) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 3.96 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 5865 Unused Serialized files (Serialized files now loaded: 0)
Unloading 46 unused Assets / (2.5 MB). Loaded Objects now: 6640.
Memory consumption went from 382.4 MB to 379.8 MB.
Total: 8.216859 ms (FindLiveObjects: 0.827016 ms CreateObjectMapping: 0.621950 ms MarkObjects: 4.993034 ms  DeleteObjects: 1.773575 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
<<<<<<< HEAD
========================================================================
Received Import Request.
  Time since last request: 836.425178 seconds.
  path: Assets/Sprite/().png
  artifactKey: Guid(5b3719c8eeb82cc499587950b9b23833) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/().png using Guid(5b3719c8eeb82cc499587950b9b23833) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'ab4285c631a3ecfcc599b8b9e89412bc') in 0.861411 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000082 seconds.
  path: Assets/Sprite/kawagoe.jpg
  artifactKey: Guid(1c116f8ac36060b42aeea1253326f115) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/kawagoe.jpg using Guid(1c116f8ac36060b42aeea1253326f115) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'da3e0aa33a6056afc0c78928913806e3') in 0.733639 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000074 seconds.
  path: Assets/Sprite/mati.png
  artifactKey: Guid(36adaea157070cd4c80c8d733787e75a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/mati.png using Guid(36adaea157070cd4c80c8d733787e75a) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'e4da2de5b211a36a13b165d5707bf1f1') in 0.060764 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000094 seconds.
  path: Assets/Sprite/tanbatti_ro.png
  artifactKey: Guid(23232a79c9b39ef41bae5a3513b2b4fd) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/tanbatti_ro.png using Guid(23232a79c9b39ef41bae5a3513b2b4fd) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'cff00df0d585107d1be118af8c734c54') in 0.297194 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000094 seconds.
  path: Assets/Sprite/kyouin_.png
  artifactKey: Guid(f89c320546dce154ab66f279b0f05f3e) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/kyouin_.png using Guid(f89c320546dce154ab66f279b0f05f3e) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '65270229d7a5b33f0f1083f05fe410e6') in 0.301383 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000083 seconds.
  path: Assets/Sprite/teeper.png
  artifactKey: Guid(f2247267926c57c4589830d43968e0f7) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/teeper.png using Guid(f2247267926c57c4589830d43968e0f7) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '484eed49e1e87bddfba1a9a10afddede') in 0.056923 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000100 seconds.
  path: Assets/Sprite/.png
  artifactKey: Guid(cdf7a4dc8e4de8f45b5ed98ca9a99f0f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/.png using Guid(cdf7a4dc8e4de8f45b5ed98ca9a99f0f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'e59e20ec42ce83d4b9038ce6a29c5ef5') in 0.047887 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000092 seconds.
  path: Assets/Sprite/tanbatti.png
  artifactKey: Guid(a6a1bf09735343241935160eea394a07) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/tanbatti.png using Guid(a6a1bf09735343241935160eea394a07) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '6954a3463628b11239a58851ad9ff9d4') in 0.156098 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000104 seconds.
  path: Assets/Sprite/_.png
  artifactKey: Guid(138ca4f7dd62ec74e8c42c270850656f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/_.png using Guid(138ca4f7dd62ec74e8c42c270850656f) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '976bbffa7290c9179aa6da507e0551ce') in 0.093493 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000080 seconds.
  path: Assets/Sprite/Background.png
  artifactKey: Guid(c5e876bc4e1934c41baff4b92f626a12) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/Background.png using Guid(c5e876bc4e1934c41baff4b92f626a12) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'd23e55119360fe9dc5c1919dad16047d') in 0.232617 seconds 
========================================================================
Received Import Request.
  Time since last request: 0.000098 seconds.
  path: Assets/Sprite/time.png
  artifactKey: Guid(35f92223fed89724d8972b63ee3e64a9) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Sprite/time.png using Guid(35f92223fed89724d8972b63ee3e64a9) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'f639bdade45e570d8d4c648b0d1ca2c8') in 0.064572 seconds 
Editor requested this worker to shutdown with reason: Scaling down because of idle timeout
AssetImportWorker is now disconnected from the server
Process exiting
=======
>>>>>>> 1c6c40fd475fa522b1ce374141e15cd617f8f5ca
